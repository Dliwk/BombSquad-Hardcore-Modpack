import bs, bsSpaz; import bsBomb
import random
from bsSpaz import SpazBot, SpazBotDeathMessage
from bsBomb import ExplodeHitMessage
try: from .advanced import get_settings
except ImportError: get_settings = lambda : {}

# written by drov.drov

PLAYER_SPAZ_INIT = bsSpaz.PlayerSpaz.__init__
SPAZBOT_INIT = bsSpaz.SpazBot.__init__
SPAZBOT_HANDLE_MESSAGE = bsSpaz.SpazBot.handleMessage
BLAST_INIT = bsBomb.Blast.__init__
BOMB_INIT = bsBomb.Bomb.__init__

class ZeroGameFactory(object):
    def __init__(self):
        factory = bs.Bomb.getFactory()
        self.poisonBombTex = bs.getModel('bomb')
        self.poisonBombModel = bs.getTexture('bombColor')
        self.poisonBlastMaterial = bs.Material()
        self.poisonBlastMaterial.addActions(
            conditions=(('theyHaveMaterial', bs.getSharedObject('objectMaterial'))),
            actions=(('modifyPartCollision', 'collide', True),
                     ('modifyPartCollision', 'physical', False),
                     ('call', 'atConnect', poison_bomb_explode)))
        self.blastMaterial = factory.blastMaterial
        self.bombMaterial = factory.bombMaterial
        self.normalSoundMaterial = factory.normalSoundMaterial
        self.explodeSounds = factory.explodeSounds
        self.debrisFallSound = factory.debrisFallSound
        self.getRandomExplodeSound = factory.getRandomExplodeSound
        self.teleportSound = bs.getSound('block')
        del factory

def getFactory():
    activity = bs.getActivity()
    if activity is None: raise Exception("no current activity")
    try: return activity._sharedZeroGameFactory
    except Exception:
        f = activity._sharedZeroGameFactory = ZeroGameFactory()
        return f

def on_begin():
    def __init__(self, color=(1, 1, 1), highlight=(0.5, 0.5, 0.5), character="Spaz", player=None, powerupsExpire=True):
        PLAYER_SPAZ_INIT(self, color=color, highlight=highlight, character=character, player=player, powerupsExpire=powerupsExpire)
        if player.exists(): self.effects = Effect(owner=self.node)
    bsSpaz.PlayerSpaz.__init__ = bs.PlayerSpaz.__init__ = __init__
    def __init__(self):
        SPAZBOT_INIT(self)
        self.hitPoints = self.hitPointsMax = getattr(self, 'hp', 1000)
        self._punchPowerScale = getattr(self, 'ph', 1.6)
    bsSpaz.SpazBot.__init__ = bs.SpazBot.__init__ = __init__
    def handleMessage(self, msg):
        self._handleMessageSanityCheck()
        if not hasattr(self, 'is_boss'): self.is_boss = False
        if self.is_boss:
            if isinstance(msg, bs.HitMessage):
                if msg.hitSubType in ['bossBlast', 'impact', 'poison', 'landMine'] or msg.sourcePlayer is None: return True
                activity = self._activity()
                if msg.flatDamage: dmg = msg.flatDamage * 1.0
                else: dmg = 0.22 * self.node.damage
                if activity is not None:
                    if msg.sourcePlayer is not None and msg.sourcePlayer.exists() and dmg > 0.0: activity.handleMessage(ZeroBossHitMessage(msg.hitType, msg.hitSubType, msg.sourcePlayer, dmg*1.0))
            if isinstance(msg, bs.DieMessage):
                activity = self._activity()
                if activity is not None: activity.handleMessage(ZeroBossDeathMessage(self, None, msg.how))
            SPAZBOT_HANDLE_MESSAGE(self, msg=msg)
        else: SPAZBOT_HANDLE_MESSAGE(self, msg=msg)
    bsSpaz.SpazBot.handleMessage = bs.SpazBot.handleMessage = handleMessage
    def __init__(self, position=(0,1,0), velocity=(0,0,0), blastRadius=2.0, blastType="normal", sourcePlayer=None, hitType='explosion', hitSubType='normal'):
        if blastType == 'poison':
            bs.Actor.__init__(self)
            factory = getFactory()
    
            self.blastType = blastType; self.sourcePlayer = sourcePlayer
            self.hitType = hitType; self.hitSubType = hitSubType; self.radius = blastRadius
    
            materials = (factory.poisonBlastMaterial, )
            self.node = bs.newNode('region', delegate=self, attrs={
                'position': (position[0], position[1]-0.1, position[2]),
                'scale': (self.radius, self.radius, self.radius),
                'type': 'sphere',
                'materials': materials})
            bs.gameTimer(10, self.node.delete)
    
            explosion = bs.newNode("explosion", attrs={
                'position': position,
                'velocity':(velocity[0], max(-1.0,velocity[1]), velocity[2]),
                'radius':self.radius,
                'big': False,
                'color': (1, 0.8, 0)})
            bs.gameTimer(1000, explosion.delete)
    
            bs.emitBGDynamics(position=position, velocity=velocity, count=int(1.0+random.random()*4), emitType='tendrils',tendrilType='thinSmoke')
            bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*4), emitType='tendrils', tendrilType='smoke')
            bs.emitBGDynamics(position=position, emitType='distortion', spread=2.0)
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=velocity, count=30, spread=2.0, scale=0.4, chunkType='rock', emitType='stickers')        
            bs.gameTimer(50, _doEmit)
    
            light = bs.newNode('light', attrs={
                'position': position,
                'volumeIntensityScale': 10.0,
                'color': (1, 0.3, 0.1)})
            bs.animate(light, "intensity", {0: 0, 10: 0.5, 20: 1.0, 2000: 0.5, 2750: 0})
            bs.animate(light, "radius", {0: 0, 10: 0.5, 20: 1.0, 2000: 0.5, 2750: 0})
            bs.gameTimer(2750, light.delete)
    
            scorch = bs.newNode('scorch', attrs={
                'position': position,
                'size': self.radius*0.5 if self.blastType != "dirty" else self.radius*0.25 if self.blastType == 'jumping' else self.radius*1.2,
                'big': True if self.blastType == 'dirt' else False,
                'color': (light.color[0]-0.05, light.color[1]-0.05, light.color[2]-0.07)})
            bs.animate(scorch, "presence",{0: 0, 60: 0.55, 2000: 1, 5000: 0})
            bs.gameTimer(5000, scorch.delete)
    
            bs.playSound(factory.getRandomExplodeSound(), position=position)
            bs.playSound(factory.debrisFallSound, position=position)
            bs.shakeCamera(1.0)
        else: BLAST_INIT(self, position=position, velocity=velocity, blastRadius=blastRadius, blastType=blastType, sourcePlayer=sourcePlayer, hitType=hitType, hitSubType=hitSubType)
        bsBomb.Blast.__init__ = bs.Blast.__init__ = __init__
        def __init__(self, position=(0,1,0), velocity=(0,0,0), bombType='normal', blastRadius=2.0, sourcePlayer=None, owner=None):
            if bombType == 'poison':
                bs.Actor.__init__(self)
                factory = getFactory()
        
                self.bombType = bombType; self._exploded = False
            
                self.blastRadius = blastRadius
                self._explodeCallbacks = []
                self.sourcePlayer = sourcePlayer
                self.hitType = 'explosion'; self.hitSubType = self.bombType
        
                if owner is None: owner = bs.Node(None)
                self.owner = owner
        
                materials = (factory.bombMaterial, bs.getSharedObject('objectMaterial'), factory.normalSoundMaterial)
            
                model = factory.poisonBombModel
                tex = factory.poisonBombTex
                def fuse(fuseTime=3000):
                    if not hasattr(self, 'node'): return
                    if self.node.exists(): 
                        if self.bombType != 'firework':
                            sound = bs.newNode('sound', owner=self.node, attrs={'sound': factory.fuseSound, 'volume': 0.25})
                            self.node.connectAttr('position', sound, 'position')
                        if self.node.getNodeType() == 'bomb': bs.animate(self.node, 'fuseLength', {0: 1.0, fuseTime: 0.0})
                        bs.gameTimer(fuseTime, bs.WeakCall(self.handleMessage, ExplodeMessage()))
                fuseTime = 4500;
                self.node = bs.newNode('bomb', delegate=self, attrs={
                    'position': position,
                    'velocity': velocity,
                    'body': 'sphere',
                    'model': model,
                    'shadowSize':0.3,
                    'colorTexture': tex,
                    'reflection': 'soft',
                    'reflectionScale': (1, 1.5, 1),
                    'materials': materials})
                fuse(fuseTime=fuseTime)
                bs.animate(self.node, "modelScale", {0: 0, 200: 1.3, 260: 1})
            else: BOMB_INIT(self, position=position, velocity=velocity, bombType=bombType, blastRadius=blastRadius, sourcePlayer=sourcePlayer, owner=owner)
            if 'fuseTime' not in dir() or fuseTime is None: return
            settings = get_settings() 
            if settings.get("timer_before_the_bomb_explode", True):
                m = bs.newNode('math', attrs={'input1': (0, 0.45, 0), 'operation': 'add'})
                self.node.connectAttr('position', m, 'input2')
                self.timer = bs.newNode('text', owner=self.node, attrs={
                    'text': '( )',
                    'position': (0, 0, 0),
                    'color': (0,3,0),
                    'scale': 0,
                    'inWorld': True,
                    'hAlign': 'center'})
                m.connectAttr('output', self.timer, 'position')        
                bs.animate(self.timer, 'scale', {0: 0.0, 240: 0.009})
                bs.animateArray(self.timer, 'color',3, {0: (0,3,0), fuseTime: (3,0,0)}, False)
        bsBomb.Bomb.__init__ = bs.Bomb.__init__ = __init__

def on_end():
    bsSpaz.PlayerSpaz.__init__ = bs.PlayerSpaz.__init__ = PLAYER_SPAZ_INIT
    bsSpaz.SpazBot.__init__ = bs.SpazBot.__init__ = SPAZBOT_INIT
    bsSpaz.SpazBot.handleMessage = bs.SpazBot.handleMessage = SPAZBOT_HANDLE_MESSAGE
    bsBomb.Blast.__init__ = bs.Blast.__init__ = BLAST_INIT
    bsBomb.Bomb.__init__ = bs.Bomb.__init__ = BOMB_INIT

class ZeroBossHitMessage(object):
    def __init__(self, type, subType, player, damage):
        self.type = type
        self.subType = subType
        self.sourcePlayer = player
        self.damage = damage
ZeroBossDeathMessage = SpazBotDeathMessage

class Effect(object):
    settings = get_settings()
    def __init__(self, owner=None):
        if not self.settings.get("timer_the_disappearance_of_the_effect", False): return

        if owner is None: owner = bs.Node(None)
        self.owner = owner

        self.effect = {}
        self.effect['text'] = bs.newNode('text', owner=self.owner, attrs={
            'text': '', 
            'inWorld': True,
            'shadow': 0.15,
            'flatness': 1,
            'color': (1, 1, 1),
            'scale': 0,
            'hAlign': 'center'})
        self.effect['text'].addDeathAction(bs.WeakCall(self.delete))
    def add(self, text = "Example", time = 5000, color = (1, 1, 1)):
        if not self.settings.get("timer_the_disappearance_of_the_effect", False): return
        if not self.owner.exists(): 
            self.delete(); return
        r = {"text_pos": (0.8, 1, 0), "timer_pos": (0.8, 0.2, 0)}
        for c in r:
            if c not in self.effect: self.effect[c] = bs.newNode('math', owner=self.owner, attrs={'input1': r[c], 'operation': 'add'})
            self.owner.connectAttr('position', self.effect[c], 'input2')
        if self.effect.get("timer", None) is not None and self.effect["timer"].exists(): self.effect["timer"].delete()
        self.effect["timer"] = bs.newNode('shield', owner=self.owner, attrs={'radius': 0, 'color': (0, 0, 0), 'hurt': 0, 'alwaysShowHealthBar': True})
        self.effect["text"].text = text
        self.effect["text"].color = color
        for c in ['timer', 'text']: self.effect[c+'_pos'].connectAttr('output', self.effect[c], 'position')
        bs.animate(self.effect['text'], 'scale', {0: 0, 300: 0.0085})
        bs.animate(self.effect['timer'], 'hurt', {0: 0, int(time): 1})    
        bs.gameTimer(time, bs.WeakCall(self.reset))
    def reset(self):
        if hasattr(self, "effect"):
            if self.effect.get("text", None) is not None and self.effect["text"].exists(): self.effect["text"].text = ""
            if self.effect.get("timer", None) is not None and self.effect["timer"].exists(): self.effect["timer"].delete()
    def delete(self):
        if hasattr(self, "effect") and self.effect is not None:
            for i in self.effect:
                node = self.effect[i]
                if getattr(node, 'exists', lambda : False)(): node.delete()
            self.effect = None; del self.effect

class AlertMessage(object):
    def __init__(self, owner=None):
        if owner is None or not owner.exists(): return
        self.owner = owner; spaz = self.owner.getDelegate()
        if hasattr(spaz, "_text") and spaz._text.exists(): spaz._text.delete()
        m = bs.newNode('math', owner=self.owner, attrs={'input1': (0, 2.325, 0), 'operation': 'add'})
        self.owner.connectAttr('position', m, 'input2')
        spaz._text = text = bs.newNode('text', owner=self.owner, attrs={'text': 'Alert!',
            'inWorld': True,
            'position': (0, 0, 0),
            'color': (3, 0, 0),
            'scale': 0,
            'hAlign':'center'})
        m.connectAttr('output', text, 'position')
        bs.animate(text, 'scale', {0:0, 250: 0.0095, 2000: 0.0095, 2500: 0})
        bs.animate(text, 'opacity', {0: 0.6, 250: 1, 500: 0.6}, loop=True)
        bs.gameTimer(2500, text.delete)

def poison_bomb_explode():
    node = bs.getCollisionInfo('opposingNode')
    if node is not None and node.exists():
        blast = bs.getCollisionInfo('sourceNode').getDelegate()
        blastType = blast.blastType; t = blast.node.position
        node.handleMessage(bs.HitMessage(pos=t, velocity=(0,0,0), magnitude=800, hitType='explosion', hitSubType='poison', radius=2, sourcePlayer=blast.sourcePlayer, kickBack = 0))

        if node.getNodeType() != 'spaz': return
        spaz = node.getDelegate()
        def damage(cnt):
            if spaz is None or not spaz.exists(): return
            spaz.hitPoints -= 6.1
            if spaz.hitPoints <= 0: spaz.node.handleMessage(bs.DieMessage(how='impact')); return
            cnt += 1
            if cnt >= 10 and cnt % 10 == 0: spaz.node.hurt = 1.0 - float(spaz.hitPoints/spaz.hitPointsMax)
            if cnt < 100: bs.gameTimer(100, bs.Call(damage, cnt))
        if not hasattr(spaz, '_effects'): spaz._effects = Effect(owner=node)
        spaz._effects.add(translates["poison"], color=(0, 2, 0), time=10000)
        damage(0)

class ZeroBoss(SpazBot):
    color=(0.5, 0.5, 2.5)
    highlight=(-0.5, -0.5, -2.5)
    character = 'Snake Shadow'
    defaultBombType = 'poison'
    punchiness = 0.4
    throwiness = 0.35
    run = True
    bouncy = True
    defaultShields = True
    chargeDistMin = 0
    chargeDistMax = 0.5
    chargeSpeedMin = 1
    chargeSpeedMax = 1
    throwDistMin = 4
    throwDistMax = 9999
    pointsMult = 12000
    hp = 380200
    ph = 3.8
    defaultBombCount = 5
    is_boss = True
    def __superHandleMessage(self, msg):
        super(SpazBot, self).handleMessage(msg)

class ZeroBossBotSpecial(SpazBot):
    color=(0, 0, 0)
    highlight=(-0.5, -0.5, -2.5)
    character = 'Snake Shadow'
    defaultBombType = 'impact'
    punchiness = 0.4
    throwiness = 0.35
    run = True
    bouncy = True
    defaultShields = True
    chargeDistMin = 0
    chargeDistMax = 0.5
    chargeSpeedMin = 1
    chargeSpeedMax = 1
    throwDistMin = 4
    throwDistMax = 9999
    pointsMult = 60
    hp = 3250
    ph = 1.2
    defaultBombCount = 1

class ZeroBossBot(SpazBot):
    color=(1,1,1)
    highlight=(3, 3, 3)
    character = 'Snake Shadow'
    defaultBombType = 'normal'
    punchiness = 2.2
    throwiness = 0
    run = True
    bouncy = True
    defaultShields = True
    chargeDistMin = 0
    chargeDistMax = 0.5
    chargeSpeedMin = 1
    chargeSpeedMax = 1
    throwDistMin = 9998
    throwDistMax = 9999
    pointsMult = 30
    hp = 920
    ph = 2.2
    defaultBombCount = 1

def bsGetAPIVersion():
    return 4

def bsGetGames():
    return [ZeroGame]

def bsGetLevels():
    return [
        bs.Level('Zero Chance', displayName='${GAME}', gameType=ZeroGame, settings={'Lives Per Player': 5}, previewTexName='black'),
        bs.Level('Zero Chance Extremal', displayName='${GAME}', gameType=ZeroGame, settings={'Lives Per Player': 1}, previewTexName='nub')
    ]

class ZeroGame(bs.TeamGameActivity):

    @classmethod
    def getName(cls):
        return 'Zero Chance\'s'

    @classmethod
    def getScoreInfo(cls):
        return {'scoreName': 'Score', 'scoreType': 'points'}

    @classmethod
    def getDescription(cls, sessionType):
        return 'Can you defeat the boss?'

    @classmethod
    def getSupportedMaps(cls, sessionType):
        return ['Football Stadium']

    @classmethod
    def supportsSessionType(cls, sessionType):
        return True if issubclass(sessionType, bs.FreeForAllSession) or issubclass(sessionType, bs.CoopSession) else False

    @classmethod
    def getSettings(cls, sessionType):
        return [("Lives Per Player", {
                'default': 5, 'minValue': 1,
                'maxValue': 5, 'increment': 1
            })]

    def __init__(self, settings):
        bs.TeamGameActivity.__init__(self, settings)
        self._scoreBoard = bs.ScoreBoard()
        self._bots = bs.BotSet()
        self.settings = settings
        self.factory = getFactory()

    def onTransitionIn(self):
        on_begin(); bs.TeamGameActivity.onTransitionIn(self, music='Scary')

    def onBegin(self):
        bs.TeamGameActivity.onBegin(self)
        self.damage = {'boss': 0, 'bots': 0, 'now': 0, 'next': 9000}
        self.boss = None; self.stage = 1
        self._bots.spawnBot(ZeroBoss, pos=(0, 0.5, 0), spawnTime=5000, onSpawnCall=self.set_boss_node)
        self._updateTimer = bs.Timer(1000, bs.Call(self._update), repeat = True)
        self.start_time = t = bs.getGameTime()
        self._attackTimer = {t: (16000, bs.Timer(16000, bs.Call(self._rnd_attack)))}
        self._update()
        self.result = {}

    def set_boss_node(self, spaz=None):
        self.boss = spaz

    def _update_timer(self, force=False):
        stinfo = {
            0: 9999999999, 
            1: 20000, 
            2: 16000, 
            3: 12000, 
            4: 9000, 
            5: 6000, 
            6: 4200, 
            7: 3000, 
            8: 2200, 
            9: 3250, 
            10: 1800}
        tme = stinfo.get(self.stage, 1800)
        t = bs.getGameTime()
        def update():
            self._attackTimer[t] = (tme, bs.Timer(tme, bs.Call(self._rnd_attack)))
        if self._attackTimer is not None and len(self._attackTimer) > 1:
            keys = self._attackTimer.keys()
            for k in keys:
                tme_key = self._attackTimer[k][0]
                if (tme_key + k) > (t + tme): self._attackTimer.pop(k)
            if len(self._attackTimer) < 1: update()
        if force: update()

    def _rnd_attack(self):
        if self.stage > 0:
            stinfo = {1: (0, 3), 2: (4, 6), 3: (7, 10), 4: (11, 16), 5: (17, 18), 6: (19, 20), 7: (21, 23), 8: (24, 28), 9: (29, 31), 10: (32, 34)}
            while True:
                rng = stinfo.get(self.stage, (32, 34))
                rnd = random.randint(rng[0], rng[1])
                if getattr(self, 'last_attack', 0) != rnd:
                    self.last_attack = rnd
                    break
            def attack():
                self.attack_number = getattr(self, 'attack_number', 0)+1
                self._update_timer(force=True)
                if self.stage == 1:
                    if rnd == 0: self.light_attack(type='multi')
                    elif rnd == 1: self.light_attack(type='vertical')
                    elif rnd == 2: self.light_attack(type='horizontal')
                    elif rnd == 3: self.circles_on_floor()
                elif self.stage == 2:
                    if rnd == 4: self.bomb_worker()
                    elif rnd == 5: self.light_attack(type='multi')
                    elif rnd == 6: self.spawnBots()
                elif self.stage == 3:
                    if rnd == 7: self.circles_on_floor()
                    elif rnd == 8: self.impact_bombs_attack()
                    elif rnd == 9: self.spawnBots()
                    elif rnd == 10: self.light_attack(type='multi')
                elif self.stage == 4:
                    if rnd == 11: self.circles_on_floor()
                    elif rnd == 12: self.bomb_worker(count=random.randint(2,4))
                    elif rnd == 13: self.teleport(alert=True, count=(random.randint(1,3)*7))
                    elif rnd == 14: self.light_attack(type='horizontal')
                    elif rnd == 15: self.impact_bombs_attack(count=random.randint(1,2), interval=(random.randint(1,6)*1000))
                    elif rnd == 16: self.spawnBots()
                elif self.stage == 5:
                    if rnd == 17: self.spawnBots()
                    elif rnd == 18: self.bomb_worker(count=10)
                elif self.stage == 6:
                    if rnd == 19: self.light_attack(type="multi")
                    elif rnd == 20: self.impact_bombs_attack(count=random.randint(1,3), interval=1000)
                elif self.stage == 7:
                    if rnd == 21: self.bomb_worker(count=(random.randint(1,3)*random.randint(1,2)))
                    elif rnd == 22: self.special_attack(count=1)
                    elif rnd == 23: self.circles_on_floor(delay=1000, count=random.randint(15, 22), pos=random.choice(['left', 'right', 'center']))
                elif self.stage == 8:
                    if rnd == 24: self.light_attack(type="multi")
                    elif rnd == 25: self.bomb_worker(count=random.randint(3, 4))
                    elif rnd == 26: self.circles_on_floor(delay=600, count=random.randint(10, 12))
                    elif rnd == 27: self.spawnBots()
                    elif rnd == 28: self.special_attack(interval=5000, count=2)
                elif self.stage == 9:
                    if rnd == 29: self.circles_on_floor(delay=600, count=10, pos='center')
                    elif rnd == 30:
                        if random.randint(0, 3) == 1: self.special_attack(interval=100, count=5)
                        else: self.special_attack()
                    elif rnd == 31: self.light_attack(type='multi')
                elif self.stage > 9:
                    if rnd == 32: self.bomb_worker(count=1, bomb_drops=2, interval=500)
                    elif rnd == 33: self.special_attack()
                    elif rnd == 34: self.light_attack(type=random.choice(['horizontal', 'vertical']))
            if self.stage < 8 or (self.stage > 7 and getattr(self, 'attack_number', 0) % 2 == 0): self.heal()
            bs.gameTimer(1000, bs.Call(attack))
        else: self._attackTimer = None

    def _update(self):
        if len(self.players) < 1: self.endGame()
        self.damage.update({'now': self.damage.get('boss', 0)+self.damage.get('bots', 0)})
        self._update_timer(force=False)
        if self.damage['now'] > self.damage.get('next', 10000):
            if self.stage > 0:
                damage = self.damage.get('now', 0)
                dmgst = {2: 10000, 3: 16050, 4: 22500, 5: 28500, 6: 34000, 7: 39500, 8: 52000, 9: 56500, 10: 59500}
                dmgst_sorted = dmgst.keys()
                dmgst_sorted.sort()
                dmgst_sorted.reverse()
                self.stage = 1
                for i in dmgst_sorted:
                    if damage > dmgst.get(i):
                        self.stage = i
                        self.damage.update({'next': dmgst.get(self.stage+1, 999999999999999)})
                        break
                        
    def onPlayerJoin(self, player):
        if 'lives' not in player.gameData: player.gameData['lives'] = self.settings['Lives Per Player']
        bs.TeamGameActivity.onPlayerJoin(self, player=player)

    def onPlayerLeave(self, player):
        bs.TeamGameActivity.onPlayerLeave(self, player=player)

    def spawnPlayer(self, player):
        spaz = self.spawnPlayerSpaz(player)
        spaz.connectControlsToPlayer()

    def celebratePlayers(self):
        for i in self.players:
            if i.exists() and i.isAlive(): i.actor.node.handleMessage("celebrate", 10000.0)

    def heal(self):
        def spawn():
            spawnCounts = 0
            players = [i for i in self.players if i.exists() and i.isAlive() and i.actor.hitPoints < 500]
            if self.stage > 2: spawnCounts = min(2, len(players))
            if spawnCounts > 0:
                if len(players) > 0:
                    if self.getMap().defs is not None: 
                        positions = [self.getMap().defs.points.get('powerupSpawn'+str(i), (0, 5, 0)) for i in range(4)]
                        for i in range(spawnCounts): bs.Powerup(powerupType='health', position = random.choice(positions)).autoRetain()
        spawn()
        

    def checkInAlertPlayers(self, type='custom'):
        def check_position(bounds = ((-15, 15), (-2, 2)), position=None):
            if position is not None:
                if int(position[0]) in range(bounds[0][0], bounds[0][1]) and int(position[2]) in range(bounds[1][0], bounds[1][1]): return True
            return False
        boss_pos = self.boss.node.position if self.boss is not None and self.boss.exists() and self.boss.isAlive() else None
        for i in self.players:
            if i.exists() and i.isAlive():
                pos = i.actor.node.position
                if type == 'all': AlertMessage(owner=i.actor.node)
                else:
                    if (type == 'horizontal' and check_position(bounds=((-15,15), (-2,2)), position=pos)) or (type == 'vertical' and 
                        check_position(bounds=((-2,2), (-15,15)), position=pos)) or (type == 'center' and 
                        check_position(bounds=((-3,3), (-2,2)), position=pos)) or (type == 'custom' and boss_pos is not None and 
                        check_position(bounds=((-3,3), (-3,3)), position=boss_pos)): AlertMessage(owner=i.actor.node)

    def spawnBots(self):
        if (len(self._bots.getLivingBots()) < 2 and self.stage < 7) or (len(self._bots.getLivingBots()) == 0 and self.stage > 6):
            if self.stage > 1:
                for i in range(2): self._bots.spawnBot(ZeroBossBot, pos=(random.randint(-1,1),1,random.randint(-1,1)), spawnTime=1000)
            if self.stage > 2:
                for i in range(2): self._bots.spawnBot(ZeroBossBotSpecial, pos=(random.randint(-1,1),1,random.randint(-1,1)), spawnTime=1)
        else: self.light_attack('multi')

    def special_attack(self, count=1, interval=1000):
        self.checkInAlertPlayers(type="all")
        def start():
            def a(player):
                if player.exists() and player.isAlive():
                    pos = (player.actor.node.position[0], player.actor.node.position[1] + 0.5, player.actor.node.position[2])
                    player.actor.node.handleMessage("impulse", pos[0], pos[1], pos[2], 0, -2, 0, 2000, 0, 1, 0, 0, -2, 0)
            for i in self.players:
                if i.exists() and i.isAlive():
                    for c in range(random.randint(1, 3)): bs.gameTimer(interval+c*interval, bs.Call(a, i))
        for i in range(count): bs.gameTimer(interval+i*interval, bs.Call(start))

    def light_attack(self, type='vertical'):
        type = [type] if type != 'multi' else ['horizontal','vertical']
        def start():
            for i in type: ZeroBossBlast(type=i).autoRetain()
        for i in type: self.checkInAlertPlayers(type=i)
        bs.gameTimer(1500+(random.randint(0, 4)*100), bs.Call(start))

    def circles_on_floor(self, interval=30, count=None, delay=500, pos=None):
        if pos in ['left', 'right', None]: self.checkInAlertPlayers(type='all')
        elif pos == 'center': self.checkInAlertPlayers(type='center')
        if count is None: count = random.randint(40, 50)
        def spawn():
            ZeroBossBlast(type='sphere', interval=interval, count=count, delay=delay, position=pos).autoRetain()
        bs.gameTimer(500, bs.Call(spawn))

    def bomb_worker(self, count=1, bomb_drops=1, interval=1000, delay=5000):
        def start():
            ZeroBossCircle(count=bomb_drops, position=random.choice([(-8, 1.5, 0), (8, 1.5, 0), (0, 1.5, 0)]), delay=delay, interval=interval, radius=0.416)
        self.checkInAlertPlayers(type='center')
        for i in range(count): bs.gameTimer(interval+((delay-interval)*i)+(random.randint(0,10)*100), bs.Call(start))

    def teleport(self, count=1, interval=100, alert=False, sound=True):
        if self.boss is not None and self.boss.exists() and self.boss.isAlive():
            if alert: self.checkInAlertPlayers(type='custom')
            if sound and count < 2: 
                try: bs.playSound(self.factory.teleportSound, 0.5, position=self.boss.node.position)
                except: pass
            mapBounds = self.getMap().spawnPoints
            def start():
                pos = (random.uniform(mapBounds[0][0], mapBounds[1][0]), random.uniform(mapBounds[0][1], mapBounds[1][1]), random.uniform(mapBounds[0][2], mapBounds[1][2]))
                bs.emitBGDynamics(position=pos, velocity=(0.1,-1,0.1),
                    count=random.randint(30, 50), scale=0.35,
                    spread=0.2, chunkType='spark')
                self.boss.node.handleMessage("stand", pos[0], pos[1], pos[2], random.randrange(0,360))
            for i in range(count): bs.gameTimer(100+(i*interval), bs.Call(start))
        else: return 

    def impact_bombs_attack(self, count=1, interval=1000):
        self.checkInAlertPlayers(type='center')
        def start():
            for i in range(8):
                for c in [(i, i), (-i, -i), (-i, i), (i, -i)]: bs.Bomb(position=(c[0],7,c[1]), velocity=(0,0,0), bombType='impact', blastRadius=1, sourcePlayer=None).autoRetain()
        for i in range(count): bs.gameTimer(2000+(i*interval), bs.Call(start))

    def handleMessage(self, m):
        if isinstance(m, bs.PlayerSpazDeathMessage):
            bs.TeamGameActivity.handleMessage(self, m)
            self._aPlayerHasBeenKilled = True
            player = m.spaz.getPlayer()
            if not player.exists(): return
            self.scoreSet.playerLostSpaz(player)
            players = self.players
            respawnTime = 1000 + len(players)*2500
            if player.gameData.get("lives") is None: player.gameData['lives'] = self.settings['Lives Per Player']
            player.gameData['lives'] -= 1
            if player.gameData['lives'] > 0:
                player.gameData['respawnTimer'] = bs.Timer(respawnTime, bs.Call(self.spawnPlayerIfExists, player))
                player.gameData['respawnIcon'] = bs.RespawnIcon(player, respawnTime)
            respawns = 0; maxRespawns = self.settings['Lives Per Player'] * len(players)
            for p in players:
                respawns += (self.settings['Lives Per Player'] - p.gameData.get('lives', 5))
            if respawns >= maxRespawns: self.endGame()
        elif isinstance(m, ZeroBossDeathMessage):
            self.celebratePlayers()
            self.damage['bots'] += 16000
            bs.gameTimer(5000, bs.Call(self.endGame))
        elif isinstance(m, bs.SpazBotDeathMessage):
            bonus = 1000
            if self.stage > 3: bonus += 200
            if self.stage > 6: bonus += 1200
            self.damage['bots'] += bonus
        elif isinstance(m, ZeroBossHitMessage):
            mult = 1.0 * (self.stage * 0.12) if self.stage > 4 else 1.0
            self.damage['boss'] += m.damage*mult
            if m.sourcePlayer is not None: 
                if m.sourcePlayer.exists(): m.sourcePlayer.gameData['score'] = m.sourcePlayer.gameData.get('score', 0) + m.damage
            if self.boss is not None and self.boss.exists() and self.boss.isAlive():
                hp = 0
                if self.boss.hitPoints < 3000:
                    hp += m.damage * 0.65
                    if self.stage > 5: self.teleport(count=random.randint(20, 30), interval=random.randint(40,50))
                    else: self.teleport()
                elif (m.type == "punch" and m.damage >= 450) or (m.type == "explosion" and m.damage >= 1000): self.teleport()
                if self.stage > 7:
                    hp += m.damage * 0.3
                    if self.boss.hitPoints < 3000 and m.damage > 400: hp += m.damage * 0.2 # 0.15 reg
                elif m.type in ["punch", "explosion"] and m.damage > 1200: self.boss.node.handleMessage('knockout', int(m.damage/12))
                if hp > 0: self.boss.hitPoints = min(self.boss.hitPoints + hp, self.boss.hitPointsMax)
        else:
            bs.TeamGameActivity.handleMessage(self, m)

    def endGame(self):
        self.stage = 0
        results = bs.TeamGameResults()
        for team in self.teams:
            score = 0
            for player in self.players: 
                if player.getTeam() == team: score += player.gameData.get('score', 0)
            results.setTeamScore(team, int(max(0, score+self.damage['bots']*0.72+self.damage['boss'])))
        self._attackTimer = self._updateTimer = None
        on_end(); self.end(results)

class ZeroBossCircle(object):
    def __init__(self, position=(0, 1.5, 0), count=2, radius=1, interval=1000, delay=5000):
        self.pos = position
        def spawn():
            def a(velocities):
                for i in velocities: bs.Bomb(position=self.pos, velocity=i, bombType='normal', blastRadius=2.0, sourcePlayer=None).autoRetain()
            bs.gameTimer(interval, bs.Call(a, [(0, 0, -6), (0, 0, 6)]))
            bs.gameTimer(interval*2, bs.Call(a, [(-6, 0, 6), (6, 0, -6)]))
            bs.gameTimer(interval*3, bs.Call(a, [(-6, 0, 0), (6, 0, 0)]))
            bs.gameTimer(interval*4, bs.Call(a, [(6, 0, 6), (-6, 0, -6)]))
        for i in range(count): bs.gameTimer(delay*i, bs.Call(spawn))
        self.light = bs.newNode('light', attrs={'position': self.pos,'color': (1, 0.35, 0), 'radius': radius})
        bs.animate(self.light, 'intensity', {0: 0, 1000: 0.9, count*delay-interval: 0.9, count*delay: 0})
        bs.animate(self.light, 'radius', {0: radius, 700: radius, 1000: radius*1.2, 2000: radius}, loop=True)
        bs.gameTimer(count*delay, self.light.delete)

class ZeroBossLight(object):
    def __init__(self, position=(0,0,0), color=(1,0.75,0), radius=0.3, animateRadius=True, animateIntensity=True, delay=1, time=2000, radiusMultiple=1.5, radiusAnimateCounts=2, intensityScale=1.05):
        def spawn():
            light = bs.newNode('light', attrs={'position': position,
                'heightAttenuated': True,
                'volumeIntensityScale': 20,
                'color': color,
                'radius': radius})
            if animateIntensity: 
                bs.animate(light, 'intensity', {0: 0, 1000: intensityScale, time*0.75: intensityScale, time: 0})
            if animateRadius:
                animTime = int(float(1/radiusAnimateCounts) * time); bs.animate(light, 'radius', {0: radius, animTime*0.4: radius * radiusMultiple, animTime: radius}, True)
            bs.gameTimer(time, light.delete)
        bs.gameTimer(delay, bs.Call(spawn))

class ZeroBossBlast(bs.Actor):
    def __init__(self, position=None, time=5000, type='horizontal', delay=500, interval=30, count=30):
        bs.Actor.__init__(self)
        factory = self.getFactory()
        pos = ['left', 'right', 'center', None]
        if type in ['vertical', 'horizontal']:
            scale = (0.1, 10, 20) if type == 'vertical' else (20, 10, 0.1)
            count = 20 if type == 'vertical' else 30
            if type == 'vertical': self.t = t = (0, 1, -12) if position in pos else position
            else: self.t = t = (-15, 1, 0) if position in pos else position
            def b():
                self.node = bs.newNode('region', delegate=self,
                    attrs={'position': (0, t[1] - 0.1, 0),
                        'scale': scale, 'type': 'box',
                        'materials': (factory.blastMaterial, bs.getSharedObject('attackMaterial'))})
                bs.gameTimer(time, self.node.delete)
            def spawn():
                def a(cnt=0):
                    ZeroBossLight(position=(self.t[0], self.t[1], self.t[2]+cnt) if type == 'vertical' else (self.t[0]+cnt, self.t[1], self.t[2]), color=(1, 0.5, 0), radius=0.1, delay=cnt*interval, time=delay+int(time * 1.0), animateRadius=False)
                for i in range(count): bs.gameTimer(1+(i*interval), bs.Call(a, i))
                bs.gameTimer(delay, bs.Call(b))
            bs.gameTimer(interval, bs.Call(spawn))
        if type == 'sphere':
            scale = (0.6, 10, 0.6)
            self.nodes = []
            def spawn():
                if position not in ['left', 'center', 'right']: randPos = (random.randrange(-12, 12), 1, random.randrange(-5, 5)) if position is None else position
                elif position == 'center': randPos = (random.randrange(-2, 2), 0, random.randrange(-2, 2))
                elif position == 'left': randPos = (random.randrange(-5, -2), 0, random.randrange(-5, 5))
                elif position == 'right': randPos = (random.randrange(-2, 5), 0, random.randrange(-5, 5))
                else: return
                ZeroBossLight(position=(randPos[0], randPos[1] - 0.1, randPos[2]), color=(1, 0.5, 0), radius=0.1, time=(delay+int(time * 1.0)), animateRadius=True, intensityScale=0.9)
                def a():
                    node = bs.newNode('region', delegate=self, attrs={'position':(randPos[0], randPos[1]-0.1, randPos[2]),'scale': scale,'type':'sphere','materials': (factory.blastMaterial, bs.getSharedObject('attackMaterial'))})
                    self.nodes.append(node)
                    def delete():
                        self.nodes.remove(node)
                        node.delete()
                    bs.gameTimer(int(time*1.0), delete)
                bs.gameTimer(delay, bs.Call(a))
            for i in range(count): bs.gameTimer(delay+i*interval, bs.Call(spawn))
    def getFactory(cls):
        activity = bs.getActivity()
        try: return activity._sharedBombFactory
        except Exception:
            f = activity._sharedBombFactory = bsBomb.BombFactory()
            return f
    def handleMessage(self, msg):
        self._handleMessageSanityCheck()
        if isinstance(msg, bs.DieMessage):
            if hasattr(self, "node") and self.node.exists(): self.node.delete()
            if hasattr(self, "nodes"):
                for i in self.nodes:
                    if i.exists(): i.delete()
        elif isinstance(msg, ExplodeHitMessage):
            node = bs.getCollisionInfo("opposingNode")
            if node is not None and node.exists():
                if node.getNodeType() != 'spaz': return
                t = node.position
                node.handleMessage(bs.HitMessage(
                    pos=t,
                    velocity=(0,0,0),
                    magnitude=550.0,
                    hitType='explosion',
                    hitSubType='bossBlast',
                    radius=100.0,
                    sourcePlayer=bs.Player(None), 
                    kickBack=0))
                node.handleMessage('impulse', t[0], t[1]-3.0, t[2], 0, 0, 0, 2000, 0, 200.0, 1, 0, 100, 0)
        else:
            bs.Actor.handleMessage(self, msg)