# -*- coding: utf-8 -*-
import bs
import bsUtils
import bsUI
import bsSpaz
import random
import time
import weakref
import bsInternal
import os, shutil
try: from hardcore.advanced import get_settings
except: get_settings = lambda : {}

START_TIME = time.time()

env = bs.getEnvironment()
SYSTEM_SCRIPTS_PATH = env['systemScriptsDirectory']
USER_SCRIPTS_PATH = env['userScriptsDirectory']
PLATFORM = env['platform']
SUBPLATFORM = env['subplatform']
VERSION = env['version']

vrMode = env['vrMode']
interfaceType = env['interfaceType']
toolbarTest = env.get('toolbarTest', True)
debugBuild = env['debugBuild']
testBuild = env['testBuild']
kioskMode = env['kioskMode']

del env

INITIAL_TRANSITION = False

def change_menu_music():
    if not PLATFORM == 'android': return
    try: import hardcore
    except: return
    else: 
        try: path = hardcore.get_path()
        except: return
    try:
        music = {'newMenuMusic.ogg': 'menuMusic.ogg'}
        files = os.listdir(path)
        for file in files:
            if file not in music: continue
            src = SYSTEM_SCRIPTS_PATH.replace('scripts','audio') + os.path.sep + music[file]
            dst = src + '.temp'
            if os.path.exists(temp) and not os.path.exists(dst):
                try: shutil.move(src, dst)
                except: pass
                try: shutil.move(path + os.path.sep + file, src)
                except: pass
    except Exception as E: print(E)

def fireworks(self):
    def firework_emit():
        bs.emitBGDynamics(position=(random.randint(-10, 10), random.randrange(14, 15), random.randint(-10, 10)),
            velocity = tuple([1.0*random.randrange(1,2) for i in range(3)]),
            count = random.randint(1000, 1200),
            scale = 1.0, spread = 0.8, chunkType = 'spark')
    start_time = bs.getGameTime()
    def a():
        if bs.getGameTime() - start_time >= 141: self._fireworks = None; self._fireworks = bs.Timer(200000, bs.Call(fireworks, self))
        else: self._fireworks = bs.Timer(500, bs.Call(a), True); firework_emit()
    a()

def get_menu_text_pos():
    if bsInternal._getSetting("TV Border"): position = (0, -10)
    else: position = (-425, 10) if interfaceType != 'small' or vrMode else (-425, 35) 
    return position

def change_menu_text_pos(self):
    if not hasattr(self, 'moderName'): return
    def a():
        position = get_menu_text_pos()
        if self.moderName.node.position != position:
            bs.animate(self.moderName.node, 'opacity', {0: 1.0, 500: 0.0, 1000: 0.0, 2000: 1.0})
            def a():
                self.moderName.node.position = position
            bs.gameTimer(550, bs.Call(a))
    if self.moderName.node.opacity < 1.0: 
        bs.animate(self.moderName.node, 'opacity', {0: self.moderName.node.opacity, 500: 1.0})
        bs.gameTimer(500, bs.Call(a))
    else: a()
  
class MainMenuActivity(bs.Activity):
    settings = get_settings()
    def __init__(self, settings = {}):
        bs.Activity.__init__(self,settings)
        change_menu_music()

    def onTransitionIn(self):
        global INITIAL_TRANSITION
        bs.Activity.onTransitionIn(self)
        random.seed(123)
        self._logoNode = self._customLogoTexName = None
        self._wordActors = []
        if not toolbarTest:
            self.myName = bs.NodeActor(bs.newNode('text', attrs={
                'vAttach':'bottom',
                'hAlign':'center',
                'color':(1, 1, 1, 1) if vrMode else (1, 1, 1, 1),
                'flatness':1.0,
                'shadow':1.0 if vrMode else 0.5,
                'scale':(0.65 if interfaceType == 'small' or vrMode else 0.7),
                'position': (0, 25),
                'vrDepth':-10,
                'text':u'\xa9 2020 Eric Froemling'}))
            self.moderName = bs.NodeActor(bs.newNode('text', attrs={
                'vAttach':'bottom',
                'hAlign':'center',
                'color':(0.8, 0.8, 0.8, 0.8) if vrMode else (0.8, 0.8, 0.8, 0.8), 
                'flatness':1.0,
                'shadow':1.0 if vrMode else 0.5,
                'scale':(0.55 if interfaceType == 'small' or vrMode else 0.7),
                'position': get_menu_text_pos(),
                'vrDepth':-10,
                'text':u'\xa9 ModPack is created by Daniil Rakhov'}))
            text = "based on " + str(VERSION) + "\n"
            try: import hardcore
            except: text += "HardCore ModPack"
            else: text += ("HardCore ModPack v." + hardcore.get_version(False))
            if debugBuild: text += " [debug]"
            if testBuild: text += " [test]"
            self.modpackVersion = bs.NodeActor(bs.newNode('text', attrs={
                'vAttach':'bottom',
                'hAttach':'right',
                'hAlign':'right',
                'flatness':1.0,
                'vrDepth':-10,
                'shadow': 0.5,
                'color': (0.5,0.6,0.5,0.7),
                'scale':0.7 if (interfaceType == 'small' or vrMode) else 0.85,
                'position':(-260,10) if vrMode else (-10,30),
                'text': text}))
            if not INITIAL_TRANSITION:
                bs.animate(self.modpackVersion.node,'opacity', {0:0, 3000:0, 4000:1.0})
                bs.animate(self.myName.node, 'opacity', {0:0, 2300:0, 3000:1.0})
                bs.animate(self.moderName.node, 'opacity', {0:0, 2300:0, 3300:1.0})
        self.betaInfo = None
        if testBuild and not kioskMode:
            self.betaInfo = bs.NodeActor(bs.newNode('text', attrs={
                'vAttach':'center',
                'hAlign':'center',
                'color':(1,1,1,1),
                'shadow':0.5,
                'flatness':0.5,
                'scale':1,
                'vrDepth':-60,
                'position':(230,125) if kioskMode else (230,35),
                'text': bs.Lstr(resource="testBuildText")}))
            if not INITIAL_TRANSITION: bs.animate(self.betaInfo.node, 'opacity', {0:0, 1300:0, 1800:1.0})

        model = bs.getModel('thePadLevel')
        colorTexture = bs.getTexture('thePadLevelColor')
        bgTex = bs.getTexture('alwaysLandBGColor')
        g = bs.getSharedObject('globals')
        g.cameraMode = 'rotate'
        g.tint = (1.1, 1.1, 1.0)
        g.ambientColor = (1.06, 1.04, 1.03)
        g.vignetteInner = (0.99, 0.98, 0.98)

        self.bottom = bs.NodeActor(bs.newNode('terrain', attrs={
            'model': bs.getModel('thePadLevelBottom'),
            'lighting':False,
            'reflection':'soft',
            'reflectionScale':[0.45],
            'colorTexture': colorTexture}))
        self.node = bs.newNode('terrain', delegate=self, attrs={
            'collideModel': bs.getCollideModel('thePadLevelCollide'),
            'model': model,
            'colorTexture': colorTexture,
            'materials': [bs.getSharedObject('footingMaterial')]})
        self.vrBottomFill = bs.NodeActor(bs.newNode('terrain', attrs={
            'model':bs.getModel('thePadVRFillBottom'),
            'lighting':False,
            'vrOnly':True,
            'colorTexture': colorTexture}))
        self.vrTopFill = bs.NodeActor(bs.newNode('terrain', attrs={
            'model': bs.getModel('thePadVRFillTop'),
            'vrOnly': True,
            'lighting': False,
            'colorTexture': bgTex}))
        self.terrain = bs.NodeActor(bs.newNode('terrain', attrs={
            'model': model,
            'colorTexture': colorTexture,
            'reflection': 'soft',
            'reflectionScale': [0.3]}))
        self.trees = bs.NodeActor(bs.newNode('terrain', attrs={
            'model': bs.getModel('trees'),
            'lighting': False,
            'reflection': 'char',
            'reflectionScale': [0.1],
            'colorTexture': bs.getTexture('treesColor')}))
        self.bg = bs.NodeActor(bs.newNode('terrain', attrs={
            'model': bs.getModel('alwaysLandBG'),
            'color': (0.92,0.91,0.9),
            'lighting': False,
            'background': True,
            'colorTexture': bgTex}))

        self._language = None
        self._updateTimer = bs.Timer(2000, bs.Call(self._update, False), repeat=True)
        self._update(True)
        bs.gameTimer(55000, bs.Call(fireworks, self))
        bs.animateArray(g, "tint", 3, {0:(1.1,1.1,1.0), 7500:(1.25, 1.21, 1.075), 30000:(1.25, 1.21, 1.075), \
            57500:(1.1, 0.86, 0.74), 67500:(1.1, 0.86, 0.74), \
            90000:(0, 0.27, 0.51), 120000:(0, 0.27, 0.51), 142500:(1.3, 1.06, 1.02), \
            157500:(1.3, 1.06, 1.02), 180000:(1.3, 1.25, 1.2), 195500:(1.3, 1.25, 1.2), \
            220000:(1.1,1.1,1.0)})
        bsInternal._addCleanFrameCallback(bs.WeakCall(self._startPreloads))
        random.seed()
        with bs.Context('UI'):
            try: mainWindow = bsUI.gMainWindow
            except Exception: mainWindow = None
            if kioskMode: bsUI.uiGlobals['mainMenuWindow'] = bsUI.KioskWindow().getRootWidget()
            else:
                if mainWindow == 'Gather': bsUI.uiGlobals['mainMenuWindow'] = bsUI.GatherWindow(transition=None).getRootWidget()
                elif mainWindow == 'Watch': bsUI.uiGlobals['mainMenuWindow'] = bsUI.WatchWindow(transition=None).getRootWidget()
                elif mainWindow == 'Team Game Select': bsUI.uiGlobals['mainMenuWindow'] = bsUI.TeamsWindow(sessionType=bs.TeamsSession, transition=None).getRootWidget()
                elif mainWindow == 'Free-for-All Game Select': bsUI.uiGlobals['mainMenuWindow'] = bsUI.TeamsWindow(sessionType=bs.FreeForAllSession, transition=None).getRootWidget()
                elif mainWindow == 'Coop Select': bsUI.uiGlobals['mainMenuWindow'] = bsUI.CoopWindow(transition=None).getRootWidget()
                else: bsUI.uiGlobals['mainMenuWindow'] = bsUI.MainMenuWindow(transition=None).getRootWidget()
                if not bsUI._showOffer():
                    def tryAgain():
                        if not bsUI._showOffer(): bs.realTimer(2000, bsUI._showOffer)
                    bs.realTimer(2000, tryAgain)
        INITIAL_TRANSITION = True

    def _update(self, forceUpdate=False):
        if not self.settings.get("in_menu_author_name", True) and hasattr(self, 'moderName'): 
            bs.animate(self.moderName.node, 'opacity', {0: self.moderName.node.opacity, 500: 0.0})
        else: change_menu_text_pos(self)
        l = bs.getLanguage()
        if l != self._language:
            self._language = l
            self._wordActors = []
            word = (('H', (-205, -3)), ('a', (-152, -3)), ('r', (-102, -3)), ('d', (-52, -3)),
                ('C', (-2, -3)), ('o', (48, -3)), ('r', (98, -3)), ('e', (148, -3)),
                ('◉', (-28, -78)))
            delay = 500 if not INITIAL_TRANSITION else 1000
            for i, key in enumerate(word):
                letter = key[0]; pos = key[1]
                self._makeWord(letter, pos[0], pos[1], scale=1.43 if i != 8 else 3.3, delay=delay, vrDepthOffset=3, shadow=False)
                delay += 100
           
    def _makeWord(self, text, x, y, scale=1.0, delay=0, vrDepthOffset=0, shadow=True):
        wordActor = bs.NodeActor(bs.newNode('text', attrs={
            'position': (x, y),
            'big': True,
            'color': (0.95, 1.55, 0.6 + random.random() / 2 if random.random() > 0.6 else 0.6, 0.65) if not shadow else (0.0,0.0,0.2,0.08),
            'tiltTranslate': 0.11,
            'tiltTranslate': 0.09,
            'shadow': 0.2 if shadow else 0.0,
            'vrDepth': -130,
            'vAlign': 'center',
            'projectScale': 0.97 * scale,
            'scale': 1.0,
            'text': text}))
        if shadow: wordActor.node.opacityScalesShadow = False
        self._wordActors.append(wordActor)
        if not vrMode:
            c = bs.newNode("combine", owner=wordActor.node, attrs={'size': 2})
            c.connectAttr('output', wordActor.node, 'position')
            v = {"0": 720, "1": 1000}
            timeV = 0
            ts = 0.86
            for inputNum in v:
                keys = {}
                for i in range(10):
                    if inputNum == "0": keys[timeV * ts] = x + random.uniform(-1,0)
                    elif inputNum == "1": keys[timeV * ts] = y + random.uniform(0, 1)
                    timeV += v[inputNum]
                bs.animate(c, "input"+inputNum, keys, loop=True)
        bs.animate(wordActor.node, "projectScale", {0: 0, delay: 0, delay+210: scale})

    def _startPreloads(self):
        if self.isFinalized(): return
        with bs.Context(self): _preload1()
        bs.gameTimer(500,lambda: bs.playMusic('Menu'))
        
def _preload1():
    for m in ['plasticEyesTransparent', 'playerLineup1Transparent',
              'playerLineup2Transparent', 'playerLineup3Transparent',
              'playerLineup4Transparent', 'angryComputerTransparent',
              'scrollWidgetShort', 'windowBGBlotch']: bs.getModel(m)
    for t in ["playerLineup","lock"]: bs.getTexture(t)
    for tex in ['iconRunaround', 'iconOnslaught',
                'medalComplete', 'medalBronze', 'medalSilver',
                'medalGold', 'characterIconMask']: bs.getTexture(tex)
    bs.getTexture("bg")
    bs.Powerup.getFactory()
    bs.gameTimer(100, _preload2)

def _preload2():
    for m in ["powerup", "powerupSimple"]: bs.getModel(m)
    for t in ["powerupBomb", "powerupSpeed", "powerupPunch", 
        "powerupIceBombs", "powerupStickyBombs", "powerupShield",
        "powerupImpactBombs", "powerupHealth"]: bs.getTexture(t)
    for s in ["powerup01", "boxDrop", "boxingBell", 
        "scoreHit01", "scoreHit02", "dripity", 
        "spawn", "gong"]: bs.getSound(s)
    bs.Bomb.getFactory()
    bs.gameTimer(100, _preload3)

def _preload3():
    for m in ["bomb", "bombSticky", "impactBomb"]: bs.getModel(m)
    for t in ["bombColor", "bombColorIce", "bombStickyColor", "impactBombColor", "impactBombColorLit"]: bs.getTexture(t)
    for s in ["freeze", "fuse01", "activateBeep", "warnBeep"]: bs.getSound(s)
    spazFactory = bs.Spaz.getFactory()
    def _load(spaz):
        spazFactory._preload(spaz)
        bs.getTexture(bsSpaz.appearances[spaz].iconTexture)
        bs.getTexture(bsSpaz.appearances[spaz].iconMaskTexture)
    bs.gameTimer(200, _preload4)

def _preload4():
    for t in ['bar', 'meter', 'null', 'flagColor', 'achievementOutline']: bs.getTexture(t)
    for m in ['frameInset', 'meterTransparent', 'achievementOutline']: bs.getModel(m)
    for s in ['metalHit', 'metalSkid', 'refWhistle', 'achievement']: bs.getSound(s)
    bs.Flag.getFactory()
    bs.Powerup.getFactory()
    bs.gameTimer(200, _preload5)

def _preload5():
    try: import hardcore
    except: return
    else:
        try: hardcore.getHardCoreBombsFactory()
        except: pass
        try: hardcore.getHardCorePowerupsFactory()
        except: pass

class SplashScreenActivity(bs.Activity):

    def __init__(self,settings={}):
        bs.Activity.__init__(self,settings)
        self._part1Duration = 4000
        self._tex = bs.getTexture('aliSplash')
        self._tex2 = bs.getTexture('aliControllerQR')
        
    def _startPreloads(self):
        if self.isFinalized(): return
        with bs.Context(self): _preload1()
        
    def onTransitionIn(self):
        import bsInternal
        bs.Activity.onTransitionIn(self)
        bsInternal._addCleanFrameCallback(bs.WeakCall(self._startPreloads))
        self._background = bsUtils.Background(fadeTime=500, startFaded=True, showLogo=False)
        self._part = 1
        self._image = bsUtils.Image(self._tex, transition='fadeIn',
                                    modelTransparent=bs.getModel('image4x1'),
                                    scale=(800, 200), transitionDelay=500,
                                    transitionOutDelay=self._part1Duration-1300)
        bs.gameTimer(self._part1Duration, self.end)

    def _startPart2(self):
        if self._part != 1: return
        self._part = 2
        self._image = bsUtils.Image(self._tex2, transition='fadeIn',
                                    scale=(400, 400), transitionDelay=0)
        t = bsUtils._translate('tips', 'If you are short on controllers, '
                               'install the \'${REMOTE_APP_NAME}\' app\n'
                               'on your mobile devices to use them '
                               'as controllers.')
        t = t.replace('${REMOTE_APP_NAME}',bsUtils._getRemoteAppName())
        self._text = bsUtils.Text(t, maxWidth=900, hAlign='center',
                                  vAlign='center', position=(0,270),
                                  color=(1,1,1,1), transition='fadeIn')
    def onSomethingPressed(self):
        self.end()

gFirstRun = True

class MainMenuSession(bs.Session):
    def __init__(self):
        bs.Session.__init__(self)
        self._locked = False
        global gFirstRun
        if PLATFORM == 'android' and SUBPLATFORM == 'alibaba' and gFirstRun:
            bsInternal._lockAllInput()
            self._locked = True
            self.setActivity(bs.newActivity(SplashScreenActivity))
            gFirstRun = False
        else: self.setActivity(bs.newActivity(MainMenuActivity))

    def onActivityEnd(self,activity,results):
        if self._locked: bsInternal._unlockAllInput()
        self.setActivity(bs.newActivity(MainMenuActivity))
        
    def onPlayerRequest(self,player):
        activity = self.getActivity()
        if isinstance(activity, SplashScreenActivity):
            with bs.Context(activity): activity.onSomethingPressed()
        return False

