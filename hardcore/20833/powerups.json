import bs, bsPowerup; import bsSpaz
from bsPowerup import defaultPowerupInterval, PowerupMessage, PowerupAcceptMessage, _TouchedMessage
from bsSpaz import gPowerupWearOffTime
try: from .advanced import get_settings
except: get_settings = lambda : {}
import random
from bsInternal import _getForegroundHostActivity as get_activity

env = bs.getEnvironment()
SYSTEM_PATH = env['systemScriptsDirectory'].replace('scripts', '')
del env

NEW_POWERUPS = (('infinityBombs', 2), ('speedPunch', 2), ('fireworkBombs', 2), 
    ('heavyBombs', 3), ('poisonBombs', 2), ('yellowShield', 2), 
    ('jumpingBombs', 2), ('teleportBombs', 2), ('unbreakable', 3), 
    ('dirtyBombs', 3), ('zawarudoBombs', 1))

# written by drov.drov

NEW_POWERUPS_NAMES = [i[0] for i in NEW_POWERUPS] + ['health']
NEW_POWERUPS_BOMBS = [i for i in NEW_POWERUPS_NAMES if i.endswith('Bombs')]

POWERUP_INIT = bsPowerup.Powerup.__init__
POWERUP_HANDLE_MESSAGE = bsPowerup.Powerup.handleMessage
GET_BOMB_TYPE_TEX = bsSpaz.Spaz._getBombTypeTex
GET_RANDOM_POWERUP_TYPE = bsPowerup.PowerupFactory.getRandomPowerupType

def on_touch():
    powerup = bs.getCollisionInfo('sourceNode').getDelegate()
    powerupType = powerup.powerupType
    if powerupType in NEW_POWERUPS_NAMES and not powerup._powersGiven:
        node = bs.getCollisionInfo("opposingNode")
        if node is not None and node.exists():
            if not node.getNodeType() == 'spaz': return
            spaz = node.getDelegate(); f = getFactory()
            tex = getattr(f, powerupType+'Tex', getattr(f, 'errorTex'))
            if powerupType == 'infinityBombs':
                spaz._flashBillboard(tex)
                spaz.setBombCount(999)
                if spaz.powerupsExpire:
                    node.miniBillboard1Texture = tex
                    t = bs.getGameTime()
                    node.miniBillboard1StartTime = t
                    node.miniBillboard1EndTime = t + int(gPowerupWearOffTime*0.1)
                    spaz._multiBombWearOffFlashTimer = bs.Timer(max(1000, int(gPowerupWearOffTime*0.1)-2000), bs.WeakCall(spaz._multiBombWearOffFlash))
                    spaz._multiBombWearOffTimer = bs.Timer(int(gPowerupWearOffTime*0.1), bs.WeakCall(spaz._multiBombWearOff))
            elif powerupType in NEW_POWERUPS_BOMBS:
                spaz.bombType = powerupType.replace('Bombs','')
                spaz._flashBillboard(tex)
                if spaz.powerupsExpire:
                    node.miniBillboard2Texture = tex
                    t = bs.getGameTime()
                    node.miniBillboard2StartTime = t
                    node.miniBillboard2EndTime = t + gPowerupWearOffTime
                spaz._bombWearOffFlashTimer = bs.Timer(gPowerupWearOffTime-2000, bs.WeakCall(spaz._bombWearOffFlash))
                spaz._bombWearOffTimer = bs.Timer(gPowerupWearOffTime, bs.WeakCall(spaz._bombWearOff))
            elif powerupType == 'yellowShield':
                spaz.equipShields(decay = True)
                spaz.shieldHitPoints = spaz.shieldHitPointsMax = 900
                spaz.shield.color = (min(node.color[0], 3), min(node.color[1], 3), min(node.color[2], 3))
            elif powerupType == 'speedPunch':
                spaz._punchPowerScale = 1.2; spaz._punchCooldown = 130; spaz._hasBoxingGloves = True
                node.boxingGloves = 0 # wear off boxing gloves
                spaz._flashBillboard(tex)
                if spaz.powerupsExpire:
                    node.miniBillboard3Texture = tex
                    t = bs.getGameTime()
                    node.miniBillboard3StartTime = t
                    node.miniBillboard3EndTime = t + int(gPowerupWearOffTime*0.25)
                    spaz._boxingGlovesWearOffFlashTimer = bs.Timer(max(1000, int(gPowerupWearOffTime*0.25)-2000), bs.WeakCall(spaz._glovesWearOffFlash))
                    spaz._boxingGlovesWearOffTimer = bs.Timer(int(gPowerupWearOffTime*0.25), bs.WeakCall(spaz._glovesWearOff))
            elif powerupType == 'unbreakable':
                def wear_off_flash():
                    if not node.exists(): return
                    node.billboardTexture = tex
                    node.billboardOpacity = 1.0
                    node.billboardCrossOut = True
                def wear_off():
                    if not node.exists(): return
                    spaz._impactScale = 1.0
                    bs.playSound(f.powerdownSound, position=node.position)
                    node.billboardOpacity = 0.0
                spaz._flashBillboard(tex)
                spaz._impactScale = 0.5
                if spaz.powerupsExpire:
                    node.miniBillboard1Texture = tex
                    t = bs.getGameTime()
                    node.miniBillboard1StartTime = t
                    node.miniBillboard1EndTime = t + int(gPowerupWearOffTime*0.5)
                    spaz._unbreakableWearOffFlashTimer = bs.Timer(max(1000, int(gPowerupWearOffTime*0.5) - 2000), bs.Call(wear_off_flash))
                    spaz._unbreakableWearOffTimer = bs.Timer(int(gPowerupWearOffTime*0.5), bs.Call(wear_off))
            elif powerupType == 'pandoraBox': pass
            elif powerupType == 'health':
                if spaz._cursed:
                    spaz._cursed = False
                    factory = spaz.getFactory()
                    for attr in ['materials', 'rollerMaterials']:
                        materials = getattr(node, attr)
                        if factory.curseMaterial in materials:
                            setattr(node, attr, tuple(m for m in materials if m != factory.curseMaterial))
                    node.curseDeathTime = 0
                spaz.hitPoints = spaz.hitPointsMax
                spaz._flashBillboard(tex); node.hurt = 0
                spaz._lastHitTime = None; spaz._numTimesHit = 0
                try: bs.playSound(f.healthPowerupSound, position=node.position)
                except: pass
                
            node.handleMessage("flash")
            if powerup.exists(): powerup.handleMessage(PowerupAcceptMessage())

def getRandomPowerupType(self, forceType=None, excludeTypes=[]):
    if get_activity() is not None: 
        f = getFactory(); settings = getattr(f, 'settings', {})
        excludeTypes = set(settings.get("exclude_powerups", []) + excludeTypes)
    t = None
    if not getattr(self, '_rebuilded', False):
        self._powerupDist = []
        for powerupType, chance in NEW_POWERUPS + bsPowerup.getDefaultPowerupDistribution():
            for i in range(chance): self._powerupDist.append(powerupType)
        self._rebuilded = True
        print(self._powerupDist)
    return GET_RANDOM_POWERUP_TYPE(self, forceType=forceType, excludeTypes=excludeTypes)

def getFactory():
    activity = bs.getActivity()
    if activity is None: raise Exception("no current activity")
    if hasattr(activity, '_sharedNEWPowerupFactory'): return activity._sharedNEWPowerupFactory
    else:
        f = activity._sharedNEWPowerupFactory = PowerupFactory(); return f

def reloadFactory():
    activity = bs.getActivity()
    if activity is None: raise Exception("no current activity")
    activity._sharedNEWPowerupFactory = PowerupFactory()

class PowerupFactory(object):
    settings = get_settings()
    def __init__(self):
        factory = bsPowerup.Powerup.getFactory()

        self.model = factory.model
        self.modelSimple = factory.modelSimple

        self.jumpingBombsTex = bs.getTexture("eggTex3")
        self.speedPunchTex = bs.getTexture("achievementSuperPunch") 
        self.pandoraBoxTex = self.poisonBombsTex = self.heavyBombsTex = bs.getTexture("black")
        self.dirtyBombsTex = bs.getTexture("nub")
        self.yellowShieldTex = bs.getTexture("coin")
        self.infinityBombsTex = bs.getTexture("logo") 
        self.fireworkBombsTex = bs.getTexture("eggTex1") 
        self.zawarudoBombsTex = bs.getTexture("achievementOutline")
        self.unbreakableTex = bs.getTexture("puckColor")
        self.teleportBombsTex = bs.getTexture("bombStickyColor")
        from os import listdir
        files = ['.'.join(i.split('.')[0:-1]) for i in listdir(SYSTEM_PATH+'textures')+listdir(SYSTEM_PATH+'models')]
        if 'beerTex' in files: self.healthTex = bs.getTexture("beerTex")
        else: self.healthTex = factory.texHealth
        if 'beerModel' in files:  self.healthModel = self.healthModelSimple = bs.getModel("beerModel")
        self.errorTex = bs.getTexture("null")

        self.healthPowerupSound = factory.healthPowerupSound
        self.dropSound = factory.dropSound
        self.powerupSound = bs.getSound("ooh")
        self.powerdownSound = bs.getSound("pixie2")
        self.powerupAcceptMaterial = factory.powerupAcceptMaterial
        self.powerupMaterial = bs.Material()
        self.powerupMaterial.addActions(
            conditions=(("theyHaveMaterial",self.powerupAcceptMaterial)),
            actions=(("modifyPartCollision","collide",True),
                     ("modifyPartCollision","physical",False),
                     ("call","atConnect",on_touch)))
        self.powerupMaterial.addActions(
            conditions=("theyHaveMaterial",
                        bs.getSharedObject('pickupMaterial')),
            actions=(("modifyPartCollision","collide",True)))
        self.powerupMaterial.addActions(
            conditions=("theyHaveMaterial",
                        bs.getSharedObject('footingMaterial')),
            actions=(("impactSound",self.dropSound,0.5,0.1)))
        del factory, files

def _getBombTypeTex(self):
    if self.bombType+'Bombs' in NEW_POWERUPS_BOMBS:
        f = getFactory()
        if hasattr(f, self.bombType+'BombsTex'): return getattr(f, self.bombType+'BombsTex')
        else: return f.errorTex
    else: return GET_BOMB_TYPE_TEX(self)

def __init__(self, position=(0,1,0), powerupType='tripleBombs', expire=True):
    customPowerup = powerupType in NEW_POWERUPS_NAMES
    factory = getFactory()
    if customPowerup:
        bs.Actor.__init__(self)
        tex = getattr(factory, powerupType+"Tex")
        model = getattr(factory, powerupType+"Model", factory.model)
        modelSimple = getattr(factory, powerupType+"ModelSimple", factory.modelSimple)
        if tex is None: 
            tex = factory.errorTex
            print("can not find texture in factory of this powerup-type: "+powerupType)
        if len(position) != 3: raise Exception("expected 3 floats for position")
        self.powerupType = powerupType; self._powersGiven = False

        if powerupType == 'poisonBombs': refScale = (0, 3, 0); ref = 'soft'
        elif powerupType == 'pandoraBox': refScale = (1, 1, 1); ref = 'soft'
        elif powerupType == 'dirtyBombs': refScale = (1, 0.4, 0.16); ref = 'soft'
        else: refScale = [0.95]; ref = 'powerup'
        
        self.node = bs.newNode('prop',
            delegate=self,
            attrs={'body': 'box',
                   'position': position,
                   'model': model,
                   'lightModel': modelSimple,
                   'shadowSize': 0.48,
                   'colorTexture': tex,
                   'reflection': ref,
                   'reflectionScale': refScale,
                   'materials': (factory.powerupMaterial, bs.getSharedObject('objectMaterial'))})
        if powerupType == 'pandoraBox': bs.animateArray(self.node, 'reflectionScale', 3, {0: (1, 1, 1), 1500: (5, 5, 5), 3000: (-5, -5, -5), 4500: (1, 1, 1)}, True)
    else: POWERUP_INIT(self, position=position, powerupType=powerupType, expire=expire)
    settings = getattr(factory, 'settings', {})
    if settings.get("powerup_lighting", True):
        self.light = bs.newNode('light', owner=self.node, attrs={'position':position,'intensity': 0,'radius': 0, 'color': (random.random()*2.45,random.random()*2.45,random.random()*2.45)})
        self.node.connectAttr('position', self.light, 'position')
        bs.animate(self.light, "radius", {0:0, 140:0.04, 200:0.09, 400:0.078})
        bs.animate(self.light, "intensity", {0:1.0, 1000:1.8, 2000:1.0}, loop = True)
        bs.animateArray(self.light, "color", 3, {0:(self.light.color[0], self.light.color[1], self.light.color[2]), 1000:(self.light.color[0]-0.4, self.light.color[1]-0.4, self.light.color[2]-0.4), 1500:(self.light.color[0], self.light.color[1], self.light.color[2])}, True)
    if settings.get("timer_the_disappearance_of_the_powerup", True):
        self.timer = bs.newNode('shield', owner=self.node, attrs={'color':(1,1,1), 'radius':0.1, 'hurt':1, 'alwaysShowHealthBar':True})
        self.node.connectAttr('position', self.timer, 'position')
        bs.animate(self.timer, 'hurt', {0:0, defaultPowerupInterval-1000:1})
    def delete():
        if self.node is not None and self.node.exists():
            if hasattr(self, "light") and self.light.exists(): 
                bs.animate(self.light, "radius", {0:0.078, 100:0})
                bs.gameTimer(100, self.light.delete)
            if hasattr(self, "timer") and self.timer.exists():
                bs.gameTimer(100, self.timer.delete)
    bs.gameTimer(defaultPowerupInterval-1000, bs.Call(delete))
    if customPowerup:
        curve = bs.animate(self.node, "modelScale", {0: 0, 140: 1.6, 200: 1})
        bs.gameTimer(200, curve.delete)
        if expire: 
            bs.gameTimer(defaultPowerupInterval-2500, bs.WeakCall(self._startFlashing))
            bs.gameTimer(defaultPowerupInterval-1000, bs.WeakCall(self.handleMessage, bs.DieMessage()))

bsPowerup.Powerup.__init__ = bs.Powerup.__init__ = __init__
bsPowerup.PowerupFactory.getRandomPowerupType = bs.PowerupFactory.getRandomPowerupType = PowerupFactory.getRandomPowerupType = getRandomPowerupType
bsSpaz.Spaz._getBombTypeTex = bs.Spaz._getBombTypeTex = _getBombTypeTex