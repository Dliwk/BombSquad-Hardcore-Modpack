# -*- coding: utf-8 -*-
import bs, httplib, urllib2
import os, shutil; import json
from inspect import isclass as is_class
from bsUI import ConfirmWindow as ConfirmWindowUI
import time, threading

class ConfirmWindow(ConfirmWindowUI):
    def __init__(self, text="Are you sure?", description="Bruh", 
        action=None, cancelAction=None, width=360, 
        height=100, cancelIsSelected=False, color=(1, 1, 1), 
        textScale=1.0, okText=None, cancelText=None, originWidget=None):
        cancelButton=True
        self._cancelAction = cancelAction
        spacing = int(height/7)
        ConfirmWindowUI.__init__(self, text=text, action=action,
            width=width, height=height, cancelIsSelected=cancelIsSelected,
            cancelButton=cancelButton, color=color, textScale=textScale, 
            okText=okText, cancelText=cancelText, originWidget=originWidget)
        for t in self._rootWidget.getChildren():
            if t.getWidgetType() == "text" and t.exists(): t.delete()
        spacing = spacing * 0.5
        t = bs.textWidget(parent=self._rootWidget,
            position=(width*0.5, height-spacing),
            size=(0, 0), hAlign="center", vAlign="center",
            text=text, scale=textScale, color=color,
            maxWidth=width*0.9, maxHeight=height-spacing)
        height = (height*0.5) + spacing*2
        t = bs.textWidget(parent=self._rootWidget,
            position=(width*0.5, height),
            size=(0, 0), hAlign="center", vAlign="center",
            text=description, scale=textScale, color=color,
            maxWidth=width*0.9, maxHeight=height)
    def _cancel(self):
        if not self._rootWidget.exists(): return
        ConfirmWindowUI._cancel(self)
        if self._cancelAction is not None: self._cancelAction()

class ConfirmWindowUI2(ConfirmWindowUI):
    def __init__(self, text="Are you sure?", 
        action=None, width=360, height=100, cancelIsSelected=False,
        color=(1, 1, 1), textScale=1.0, okText=None, cancelText=None, 
        originWidget=None, cancelButton=True):
        ConfirmWindowUI.__init__(self, text=text, action=action,
            width=width, height=height, cancelIsSelected=cancelIsSelected,
            cancelButton=cancelButton, color=color, textScale=textScale, 
            okText=okText, cancelText=cancelText, originWidget=originWidget)
    def _ok(self):
        if not self._rootWidget.exists(): return
        bs.containerWidget(edit=self._rootWidget, transition=('outLeft' if self._transitionOut is None else self._transitionOut))
        if self._action is not None: self._action.__call__()

class ReturnTimer(threading.Thread):
    def __init__(self, lenght, *args):
        threading.Thread.__init__(self)
        if lenght < 0: raise ValueError()

        self._call = args[0] if len(args) > 0 else None
        self._args = args[1:] if len(args) > 1 else None
        self._lenght = float(lenght/1000)
    def run(self):
        try:
            time.sleep(self._lenght)
            if self._args is not None: return self._call(*self._args)
            else: return self._call()
        except Exception:
            bs.callInGameThread(bs.Call(self._call, None))    

class _DownloadFinished(object):
    def __init__(self, url, path, *args):
        global DOWNLOADS
        self.filename = path.split(os.path.sep)[-1]
        DOWNLOADS.append(self.filename)
        self.u = url
        self.p = path
        if debug > 0: print("Successfully downloaded: " + self.filename)
        call = args[0] if len(args) > 0 else None
        a = args[1:] if len(args) > 1 else None
        if call is not None: 
            if a is not None: call(*a)
            else: call()

class Downloader(threading.Thread):
    def __init__(self, download_url, download_path, rewrite_file=True, *args):
        threading.Thread.__init__(self)
        self.errors_count = self._b = 0
        
        self._url = download_url
        self._path = download_path
        self._rewrite = rewrite_file
        self._args = args
    def download(self):
        try:
            if not self._rewrite and os.path.exists(self._path): return
            if debug > 0: print("try to download from url: " + self._url)
            self.errors_count = 0
    
            u = self._u = self.open_url(url=self._url)
            f = self._f = self.open_file(path=self._path)
    
            if u is None or f is None: print("download error; " + self._url); time.sleep(1); self.run(); return
            bs.callInGameThread(self.chunk)
        except Exception as E: print(E)
    def end(self):
        self._f.close()
        self._u.close()
        if debug > 0: print(self._url + "; bytes: " + str(self._b))
        _DownloadFinished(self._url, self._path, *self._args)
    def chunk(self):
        if debug > 0: print("reading chunks...")
        u = self._u; f = self._f
        try: c = u.read(524288)
        except Exception as E:
            self.errors_count += 1
            if self.errors_count > 49: return
            if debug > 1:
                for i in ["chunk lost: ", E, "try again..."]: print(i)
            bs.realTimer(3000, self.chunk); return
        if not c: self.end(); return
        self._b += len(c)
        f.write(c); f.flush()
        bs.realTimer(1000, self.chunk)
    def open_file(self, path):
        try: f = open(path, 'w+')
        except Exception as E: 
            self.errors_count += 1; print("file open error;"); print(E)
            if self.errors_count > 4: return None
            else: return ReturnTimer(1000, self.open_file, path).start()
        else: self.errors_count = 0; return f
    def open_url(self, url): 
        try: u = urllib2.urlopen(url)
        except Exception as E: 
            self.errors_count += 1; print("url open error; "+url); print(E)
            if self.errors_count > 29: return None
            else: return ReturnTimer(1000, self.open_url, url).start()
        else: self.errors_count = 0; return u
    def run(self):
        self.download()

colorYellow = (1, 0.85, 0)
colorRed = (1, 0, 0)
colorGreen = (0, 1, 0)
debug = 2

env = bs.getEnvironment()
platform = env['platform']
USER_SCRIPTS_PATH = env['userScriptsDirectory']
SYSTEM_SCRIPTS_PATH = env['systemScriptsDirectory']
SYSTEM_DIR = os.path.sep.join(SYSTEM_SCRIPTS_PATH.split(os.path.sep)[0:-2]) if platform != 'android' else '/data/data/net.froemling.bombsquad'
GITHUB_BRANCH = 'https://raw.githubusercontent.com/DrovGamedev/BombSquad-Hardcore-Modpack/master' if hasattr(httplib, 'HTTPS') and hasattr(urllib2, 'ssl') else 'http://raw.githack.com/DrovGamedev/BombSquad-Hardcore-Modpack/master'
ERRORS = []
DOWNLOADS = []
del env

def add_scripts():
    import sys
    for path in [SYSTEM_SCRIPTS_PATH, USER_SCRIPTS_PATH]:
        path += os.path.sep + 'hardcore'
        if not os.path.exists(path): return
        sys.path.append(path)
add_scripts()
try: import hardcore
except Exception as E: INSTALLED_VERSION = 0
else: INSTALLED_VERSION = hardcore.get_version(True) if hasattr(hardcore, 'get_version') else 0
if INSTALLED_VERSION is None: INSTALLED_VERSION = 0
try: from hardcore.advanced import get_settings
except: get_settings = lambda : {}
SETTINGS = get_settings()
if debug > 0: print("installed version: " + str(INSTALLED_VERSION))

if debug > 0:
    def error_log(error=None):
        global ERRORS 
        ERRORS.append(error)
        if debug > 1: print(error)
else: error_log = lambda error=None : True

translates = {
    "Russian": {
        "installCompleted": "Установка успешно завершена!",
        "appDataReset": "Сброс данных",
        "appDataResetDesc": "Для более лучшей совместимости, требуется очистить данные игры.\nОчистить данные?",
        "storage": "Хранение",
        "storageDesc": "Кликни на \"Приложение\", если хочешь, \nчтобы данные модпака хранились в приложении.\nИначе, они будут находиться в папке модов",
        "app": "Приложение",
        "modsFolder": "Папка модов",
        "downloadStartsNow": "Загрузка сейчас начнётся.\nПожалуйста, не выходи из игры.",
        "successfullyDownloaded": "Успешно загружено: {}",
        "installThisVersion?": "Установить версию {}?",
        "updateDesc": "Найдено обновление {}.\nУстановить?",
        "update": "Обновление",
        "changelog": "Изменения"},
    "English": {
        "installCompleted": "Modpack successfully installed!",
        "appDataReset": "App Data Reset",
        "appDataResetDesc": "For better compatibility, installer need to clear the game data.\nClear data?",
        "storage": "Storage",
        "storageDesc": "Click on \"App\", if you want to save modpack data in app.\Otherwise, they will be stored in the mods folder",
        "app": "App",
        "modsFolder": "Mods Folder",
        "downloadStartsNow": "Download starts now.\nPlease, don\'t quit from game.",
        "successfullyDownloaded": "Successfully downloaded: {}",
        "installThisVersion?": "Install version {}?",
        "updateDesc": "Found update {}.\nInstall it?",
        "update": "Update",
        "changelog": "Changelog"}
}
translates = translates.get(bs.getLanguage(), translates["English"])

def has_internet_connection():
    import socket
    s = socket.socket(2, 2)
    s.settimeout(1.0)
    try: s.connect(("8.8.8.8", 80))
    except Exception: return False
    else: s.close(); return True

def download(url, path, rewrite=True, *args):
    a = tuple([url])
    a += (path, )
    a += (rewrite, )
    a += args
    with bs.Context("UI"): Downloader(*a).start()

def restart_msg():
    if debug > 1: print("send restart message...")
    bs.screenMessage(bs.Lstr(resource='settingsWindowAdvanced.mustRestartText').evaluate(), color = colorYellow)

def update(version=None, ignore_old=True, download_path=None, auto_update=False):
    global DOWNLOADS
    def download_files(download_path, data, v):
        url = (GITHUB_BRANCH+'/')
        if download_path is None: download_path = USER_SCRIPTS_PATH
        def check_end(paths, urls, c, cnt_end):
            filename = paths[c].split(os.path.sep)[-1]
            if filename == 'hardcoreModpack.data':
                try: data = json.load(open(paths[c], 'r'))
                except: data = {}
                data.update({"path": download_path})
                json.dump(data, open(paths[c], 'w+'), indent=4, sort_keys=True)
                changelog = ch = str(data.get("changelog", "").encode('utf-8'))
                for s in changelog.split('\n'): ch.replace(s, '- ' + s)
                ConfirmWindow(text=bs.Lstr(value=translates["changelog"]), description=bs.Lstr(value=ch), height=175, textScale=0.9)
            bs.screenMessage(translates["successfullyDownloaded"].format(filename), color=colorYellow)
            if len(DOWNLOADS)-1 == cnt_end: 
                import sys
                try: import script_replacer
                except: restart_msg()
                else: script_replacer._getModulesWithCall("bruh")
                print("system scripts replaced")
                bs.realTimer(3000, bs.Call(sys.exit, 1))
            else: 
                c += 1
                bs.realTimer(500, bs.Call(download, urls[c], paths[c], True, check_end, paths, urls, c, cnt_end))
        cnt_end = len(data[v])
        paths = []
        urls = []
        for u in data[v]:
            u = str(u.encode('utf-8')); file = str(data[v][u].encode('utf-8'))
            file = file.replace(":", os.path.sep); u = (url + u)
            filename = file.split(os.path.sep)[-1]
            p = download_path + os.path.sep + file if file != 'installer.py' else USER_SCRIPTS_PATH + os.path.sep + file
            dirs = p.replace(os.path.sep + filename, "")
            if debug > 1: print("dir: " + dirs)
            if not os.path.exists(dirs):
                try: os.makedirs(dirs)
                except: pass
            if debug > 1: print("download path: " + p)
            paths.append(p)
            urls.append(u)
        download(urls[0], paths[0], True, check_end, paths, urls, 0, cnt_end)
    def confirm_download(path, download_path):
        if not os.path.exists(path): return
        f = open(path, 'r')
        try: data = json.load(f)
        except: data = {}
        if version is None and 'last_version' in data: v = str(data['last_version'])
        elif str(version) in data: v = str(version)
        else: return
        if v not in data: return
        if ignore_old and INSTALLED_VERSION >= int(v): 
            if debug > 0: print("installed version equals or bigger than installing version; return")
            return
        call = bs.Call(download_files, download_path, data, v)
        if not auto_update: ConfirmWindowUI2(text=bs.Lstr(value=translates["installThisVersion?"].format(v)), action=call)
        else: ConfirmWindow(text=bs.Lstr(value=translates["update"]), description=bs.Lstr(value=translates["updateDesc"].format(v)), height=175, textScale=0.9, action=call)
      
    DOWNLOADS = []
    if not has_internet_connection(): 
        if debug > 1: print("no internet connection")
        return
    filename = 'versions.json' 
    url = GITHUB_BRANCH + '/' + filename
    path = USER_SCRIPTS_PATH + os.path.sep + filename
    download(url, path, True, confirm_download, path, download_path)

def delete_path(path=None):
    path += os.path.sep + 'hardcore'
    if not os.path.exists(path): return
    try: shutil.rmtree(path)
    except: pass

def delete():
    for path in [SYSTEM_SCRIPTS_PATH, USER_SCRIPTS_PATH]: delete_path(path=path)
    delete_files = ['installer','script_replacer','ui','mainmenu']
    temp_files = ['bsUI','bsMainMenu','menuMusic']
    try: import hardcore
    except: path = USER_SCRIPTS_PATH
    else: path = hardcore.get_path()
    for file in os.listdir(path):
        f = '.'.join(file.split('.')[0:-1])
        if f in delete_files:
            try: os.remove(path + os.path.sep + file)
            except: pass
    for root, dirs, files in os.walk(SYSTEM_SCRIPTS_PATH.replace("scripts","")):
        for file in files:
            if file.endswith('.temp'):
                p = root + os.path.sep
                try: shutil.move(p + file, p + file.replace('.temp', ''))
                except: pass
    restart_msg()

def update_modpack():
    def d(path):
        bs.realTimer(3000, bs.Call(update, None, True, path))
    def a(path=None):
        try: import hardcore
        except: pass
        else: 
            p = hardcore.get_path()
            if p != path: delete_path(p)
        bs.screenMessage(translates["downloadStartsNow"], color=colorYellow)
        import bsInternal
        bsInternal._addCleanFrameCallback(bs.Call(d, path))
    def reset():
        if os.path.exists(SYSTEM_DIR): 
            try: shutil.rmtree(SYSTEM_DIR)
            except: pass
        next_window()
    def next_window():
        ConfirmWindow(text=bs.Lstr(value=translates["storage"]),
            description=bs.Lstr(value=translates["storageDesc"]),
            height=175, action=c, cancelAction=b, 
            okText=bs.Lstr(value=translates["app"]), 
            cancelText=bs.Lstr(value=translates["modsFolder"]),
            textScale=0.9)
    def b():
        a(USER_SCRIPTS_PATH)
    def c():
        a(SYSTEM_SCRIPTS_PATH)
    ConfirmWindow(text=bs.Lstr(value=translates["appDataReset"]),
        description=bs.Lstr(value=translates["appDataResetDesc"]),
        height=150, action=reset, cancelAction=next_window)

if INSTALLED_VERSION == 0 or debug > 3: bs.realTimer(5000, bs.Call(update_modpack))
elif SETTINGS.get("auto-update", False): 
    try: import hardcore
    except: path = None
    else: path = hardcore.get_path()
    bs.realTimer(5000, bs.Call(update, None, True, path, True))