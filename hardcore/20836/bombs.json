# -*- coding: utf-8 -*-
import bs, bsBomb, bsSpaz
import random

from bsInternal import _getForegroundHostActivity as get_activity
from bsBomb import ExplodeMessage

try: from .advanced import get_settings
except: get_settings = lambda : {}

NEW_BOMBS = ['teleport','jumping','heavy','dirty','firework','poison','zawarudo']

# written by drov.drov

BOMB_INIT = bsBomb.Bomb.__init__
BLAST_INIT = bsBomb.Blast.__init__
BLAST_HANDLE_MESSAGE = bsBomb.Blast.handleMessage
UPDATE_AI = bsSpaz.SpazBot._updateAI
translates = {
    "Russian": {
        "paralysis": "Паралич",
        "poison": "Отравление",
        "teleported": "Телепортирован"},
    "English": {
        "paralysis": "Paralysis",
        "poison": "Poisoning",
        "teleported": "Teleported"}
}
translates = translates.get(bs.getLanguage(), translates["English"])

def onMoveUpDownSlow(self, value):
    if not self.node.exists(): return
    self.node.moveUpDown = value*0.2

def onMoveLeftRightSlow(self, value):
    if not self.node.exists(): return 
    self.node.moveLeftRight = value*0.2

bsSpaz.Spaz.onMoveUpDownSlow = onMoveUpDownSlow
bsSpaz.Spaz.onMoveLeftRightSlow = onMoveLeftRightSlow

def dirt_bomb_in(node=None):
    if node is None: node = bs.getCollisionInfo('opposingNode')
    if node is not None and node.exists():
        if not node.getNodeType() == 'spaz': return
        blast = bs.getCollisionInfo('sourceNode').getDelegate(); spaz = node.getDelegate()
        blast.dirtyNodes = getattr(blast, 'dirtyNodes', [])
        if node not in blast.dirtyNodes: blast.dirtyNodes.append(node)
        if hasattr(spaz, '_updateAI'): spaz._slow = True
        elif hasattr(spaz, 'getPlayer'):
            player = spaz.getPlayer()
            player.assignInputCall('upDown', spaz.onMoveUpDownSlow)
            player.assignInputCall('leftRight', spaz.onMoveLeftRightSlow)
            
def dirt_bomb_out(node=None):
    if node is None: node = bs.getCollisionInfo('opposingNode')
    if node is not None and node.exists():
        if not node.getNodeType() == 'spaz': return
        spaz = node.getDelegate()
        if hasattr(spaz, '_updateAI'): spaz._slow = False
        elif hasattr(spaz, 'getPlayer'):
            player = spaz.getPlayer()
            player.assignInputCall('upDown', spaz.onMoveUpDown)
            player.assignInputCall('leftRight', spaz.onMoveLeftRight)

def dirt_bomb_death(blast=None):
    if blast is None: blast = bs.getCollisionInfo('sourceNode').getDelegate()
    for node in getattr(blast, 'dirtyNodes', []): dirt_bomb_out(node=node)

def jumping_bomb_explode(bomb, node=None):
    if hasattr(bomb, 'node') and bomb.node.exists():
        t = bomb.node.position; owner_spaz = bomb.owner
        if node == owner_spaz: return
        bomb._exploded = True
        bs.emitBGDynamics(position=t, velocity=(1+random.random(), 1+random.random(), 1+random.random()), count=50+random.randrange(10,100), spread=0.8, scale=0.6, chunkType = 'spark')
        bs.Blast(position=t, velocity=bomb.node.velocity, blastRadius=bomb.blastRadius, blastType='jumping', sourcePlayer=bomb.sourcePlayer, hitType=bomb.hitType, hitSubType=bomb.hitSubType).autoRetain()

def impact_explode():
    bomb = bs.getCollisionInfo('sourceNode').getDelegate()
    bombType = bomb.bombType
    if bombType == 'jumping': 
        node = bs.getCollisionInfo('opposingNode')
        jumping_bomb_explode(bomb=bomb, node=node)
    elif bombType == 'zawarudo': zawarudo_explode(bomb=bomb)
    else: 
        bs.Blast(position=t, velocity=bomb.node.velocity, blastRadius=bomb.blastRadius, blastType=bombType, sourcePlayer=bomb.sourcePlayer, hitType=bomb.hitType, hitSubType=bomb.hitSubType).autoRetain()
        bomb.handleMessage(bs.DieMessage(immediate=True))

def effect_set(spaz):
    if not spaz.exists(): return
    if not hasattr(spaz, '_effects'): spaz._effects = Effect(spaz.node)

def unparalize(spaz):
    if not spaz.exists(): return
    cnt = getattr(spaz, '_paralize_count', 0)
    cnt -= 1
    if cnt < 1: 
        m = spaz._savedMaterials
        spaz.node.punchMaterials = m[0]; spaz.node.rollerMaterials = m[1]; spaz.node.extrasMaterials = m[2]
        spaz.node.holdPositionPressed = spaz.node.jumpPressed = False
        del m
    spaz._paralize_count = cnt

def firework_explode(spaz):
    t = 4000
    effect_set(spaz=spaz)
    spaz._effects.add(translates["paralysis"], color=(0, 0.72, 0.65), time=t)
    cnt = getattr(spaz, '_paralize_count', 0)
    if cnt == 0: spaz._savedMaterials = [spaz.node.punchMaterials, spaz.node.rollerMaterials, spaz.node.extrasMaterials]
    spaz.node.punchMaterials = spaz.node.rollerMaterials = spaz.node.extrasMaterials = []; spaz.node.holdPositionPressed = spaz.node.jumpPressed = True
    spaz.node.handleMessage('knockout', 300.0)
    spaz._paralize_count = cnt + 1
    bs.gameTimer(t, bs.Call(unparalize, spaz))

def poison_explode(spaz):
    def damage(cnt):
        if spaz is None or not spaz.exists(): return
        spaz.hitPoints -= 6.1
        if spaz.hitPoints <= 0: spaz.node.handleMessage(bs.DieMessage(how='impact')); return
        cnt += 1
        if cnt >= 10 and cnt % 10 == 0: spaz.node.hurt = 1.0 - float(spaz.hitPoints/spaz.hitPointsMax)
        if cnt < 100: bs.gameTimer(100, bs.Call(damage, cnt))
    effect_set(spaz=spaz)
    spaz._effects.add(translates["poison"], color=(0, 2, 0), time=10000)
    damage(0)

def teleport_explode(spaz):
    t = 3000
    effect_set(spaz=spaz)
    spaz._effects.add(translates["teleported"], color=(0.71, 0.72, 0), time=t)
    if not getattr(spaz, '_teleported', False):
        mapBounds = spaz.getActivity().getMap().spawnPoints
        spaz.node.handleMessage("stand", random.uniform(mapBounds[0][0], mapBounds[1][0]), random.uniform(mapBounds[0][1], mapBounds[1][1]), random.uniform(mapBounds[0][2], mapBounds[1][2]), random.randrange(0,360))
        spaz._teleported = True
        def a():
            if spaz.exists(): spaz._teleported = False
        bs.gameTimer(t, bs.Call(a))

def zawarudo_explode(bomb=None):
    if bomb is None: return
    node = bs.getCollisionInfo('opposingNode')
    t = bomb.node.position
    if node is not None and node.exists():
        if node.getNodeType() == 'spaz':
            t = node.position; owner_spaz = bomb.owner
            if node == owner_spaz: return
            node.handleMessage(bs.HitMessage(pos=t, velocity=bomb.node.velocity, magnitude=3000, hitType='explosion', hitSubType='zawarudo', radius=2, sourcePlayer=bomb.sourcePlayer, kickBack = 0)) 
    bs.Blast(position=t, velocity=bomb.node.velocity, blastRadius=0, blastType='zawarudo', sourcePlayer=bomb.sourcePlayer, hitType=bomb.hitType, hitSubType=bomb.hitSubType).autoRetain()
    bomb.handleMessage(bs.DieMessage())

def explode():
    node = bs.getCollisionInfo('opposingNode')
    if node is not None and node.exists():
        blast = bs.getCollisionInfo('sourceNode').getDelegate()
        blastType = blast.blastType; t = blast.node.position
        if blastType not in NEW_BOMBS: raise ValueError()
        mag = 2000.0
        if blastType == 'firework': mag *= 0.2
        elif blastType == 'teleport': mag *= 0.65
        elif blastType == 'jumping': mag *= 1.8
        elif blastType == 'heavy': mag *= 1.75
        elif blastType == 'poison': mag *= 0.4

        if blastType not in ['dirt', 'zawarudo']:
            node.handleMessage(bs.HitMessage(pos=t, velocity=(0,0,0), magnitude=mag, hitType=blast.hitType, hitSubType=blast.hitSubType, radius=blast.radius, sourcePlayer=blast.sourcePlayer, kickBack = 0))

        if node.getNodeType() != 'spaz': return
        if blastType == "firework": firework_explode(node.getDelegate())
        elif blastType == "poison": poison_explode(node.getDelegate())
        elif blastType == "jumping": node.handleMessage("knockout", 110.0)
        elif blastType == "teleport": teleport_explode(node.getDelegate()); node.handleMessage("knockout", 45.0)

class BombFactory(object):
    settings = get_settings()
    def __init__(self):
        factory = bsBomb.Bomb.getFactory()
        self.fireworkBombModel = bs.getModel('tnt')
        self.heavyBombModel = self.dirtyBombModel = factory.stickyBombModel
        self.jumpingBombModel = self.teleportBombModel = self.poisonBombModel = self.zawarudoBombModel = self.errorModel = bs.getModel('bomb')

        self.teleportBombTex = bs.getTexture('bombStickyColor')
        self.poisonBombTex = self.heavyBombTex = self.dirtyBombTex = self.errorTex = bs.getTexture('bombColor')
        self.fireworkBombTex = bs.getTexture('eggTex2')
        self.jumpingBombTex = bs.getTexture('eggTex3')
        self.zawarudoBombTex = bs.getTexture('black')
        self.explodeSounds = factory.explodeSounds

        self.fuseSound = factory.fuseSound
        self.hissSound = factory.hissSound
        self.debrisFallSound = factory.debrisFallSound
        self.getRandomExplodeSound = factory.getRandomExplodeSound

        self.bombMaterial = factory.bombMaterial
        self.normalSoundMaterial = factory.normalSoundMaterial
        self.impactBlastMaterial = bs.Material()
        self.impactBlastMaterial.addActions(
            conditions=(('weAreOlderThan', 200),'and', ('theyAreOlderThan',200),'and',('evalColliding',),'and', (('theyHaveMaterial', bs.getSharedObject('footingMaterial')),'or',('theyHaveMaterial', bs.getSharedObject('objectMaterial')))),
            actions=(('call', 'atConnect', impact_explode)))
        self.blastMaterial = bs.Material()
        self.blastMaterial.addActions(
            conditions=(('theyHaveMaterial', bs.getSharedObject('objectMaterial'))),
            actions=(('modifyPartCollision', 'collide', True),
                     ('modifyPartCollision', 'physical', False),
                     ('call', 'atConnect', explode)))
        self.dirtyBlastMaterial = bs.Material()
        self.dirtyBlastMaterial.addActions(
            conditions=(('theyHaveMaterial',
                         bs.getSharedObject('objectMaterial'))),
            actions=(('modifyPartCollision','collide',True),
                     ('modifyPartCollision','physical',False),
                     ('call','atDisconnect', dirt_bomb_out),
                     ('call','atConnect', dirt_bomb_in)))
        del factory

def getNewBombsFactory():
    activity = bs.getActivity()
    if activity is None: raise Exception("no current activity")
    if hasattr(activity, '_sharedNEWBombFactory'): return activity._sharedNEWBombFactory
    else:
        f = activity._sharedNEWBombFactory = BombFactory()
        return f

def reloadFactory():
    activity = bs.getActivity()
    if activity is None: raise Exception("no current activity")
    activity._sharedNEWBombFactory = BombFactory()

class Effect(object):
    def __init__(self, owner=None):
        activity = get_activity()
        if hasattr(activity, '_sharedNEWBombFactory'): 
            self.settings = getattr(activity._sharedNEWBombFactory, 'settings', {})
        else: self.settings = get_settings()

        if not self.settings.get("timer_the_disappearance_of_the_effect", False): return

        if owner is None: owner = bs.Node(None)
        self.owner = owner

        self.effect = {}
        self.effect['text'] = bs.newNode('text', owner=self.owner, attrs={
            'text': '', 
            'inWorld': True,
            'shadow': 0.15,
            'flatness': 1,
            'color': (1, 1, 1),
            'scale': 0.0085,
            'opacity': 0,
            'hAlign': 'center'})
        self.effect['text'].addDeathAction(bs.WeakCall(self.delete))
    def add(self, text = "Example", time = 5000, color = (1, 1, 1)):
        if not self.settings.get("timer_the_disappearance_of_the_effect", False): return
        if not self.owner.exists(): 
            self.delete(); return
        r = {"text_pos": (0.8, 1, 0), "timer_pos": (0.8, 0.2, 0)}
        for c in r:
            if c not in self.effect: self.effect[c] = bs.newNode('math', owner=self.owner, attrs={'input1': r[c], 'operation': 'add'})
            self.owner.connectAttr('position', self.effect[c], 'input2')
        if self.effect.get("timer", None) is not None and self.effect["timer"].exists(): self.effect["timer"].delete()
        self.effect["timer"] = bs.newNode('shield', owner=self.owner, attrs={'radius': 0, 'color': (0, 0, 0), 'hurt': 0, 'alwaysShowHealthBar': True})
        self.effect["text"].text = text
        self.effect["text"].color = color
        for c in ['timer', 'text']: self.effect[c+'_pos'].connectAttr('output', self.effect[c], 'position')
        bs.animate(self.effect['text'], 'opacity', {0: 0, 300: 0.8})
        bs.animate(self.effect['timer'], 'hurt', {0: 0, int(time): 1})    
        bs.gameTimer(time, bs.WeakCall(self.reset))
    def reset(self, immediate=False):
        if hasattr(self, "effect"):
            if self.effect.get("text", None) is not None and self.effect["text"].exists(): 
                def a():
                    if hasattr(self, 'effect'): self.effect["text"].text = ""
                if immediate: a()
                else: 
                    bs.animate(self.effect['text'], 'opacity', {0: 0.8, 1000: 0})
                    bs.gameTimer(1000, bs.Call(a))
            if self.effect.get("timer", None) is not None and self.effect["timer"].exists(): self.effect["timer"].delete()
    def delete(self):
        if hasattr(self, "effect") and self.effect is not None:
            for i in self.effect:
                node = self.effect[i]
                if getattr(node, 'exists', lambda : False)(): node.delete()
            self.effect = None; del self.effect

def __bombs_init__(self, position=(0,1,0), velocity=(0,0,0), bombType='normal', blastRadius=2.0, sourcePlayer=None, owner=None):
    customBomb = bombType in NEW_BOMBS
    factory = getNewBombsFactory()
    if customBomb:
        bs.Actor.__init__(self)

        self.bombType = bombType
        self._exploded = False
    
        self.blastRadius = blastRadius
        if self.bombType == 'jumping': self.blastRadius *= 0.9
        elif self.bombType == 'firework': self.blastRadius *= 1.75
        elif self.bombType == 'heavy': self.blastRadius *= 0.945
        elif self.bombType == 'poison': self.blastRadius *= 1.2

        self._explodeCallbacks = []
        self.sourcePlayer = sourcePlayer
        self.hitType = 'explosion'; self.hitSubType = self.bombType

        if owner is None: owner = bs.Node(None)
        self.owner = owner

        materials = (factory.bombMaterial, bs.getSharedObject('objectMaterial'))
        if self.bombType in ['jumping', 'zawarudo']: materials = materials + (factory.impactBlastMaterial, )
        if self.bombType != 'firework': materials = materials + (factory.normalSoundMaterial, )
    
        model = getattr(factory, self.bombType+'BombModel', factory.errorModel)
        tex = getattr(factory, self.bombType+'BombTex', factory.errorTex)
        def fuse(fuseTime=3000):
            if not hasattr(self, 'node'): return
            if self.node.exists(): 
                if self.bombType != 'firework':
                    sound = bs.newNode('sound', owner=self.node, attrs={'sound': factory.fuseSound, 'volume': 0.25})
                    self.node.connectAttr('position', sound, 'position')
                if self.node.getNodeType() == 'bomb': bs.animate(self.node, 'fuseLength', {0: 1.0, fuseTime: 0.0})
                bs.gameTimer(fuseTime, bs.WeakCall(self.handleMessage, ExplodeMessage()))

        fuseTime = None
        if self.bombType == 'firework':
            fuseTime = 4500;
            self.node = bs.newNode('prop', delegate=self, attrs={
                'position': position,
                'velocity': velocity,
                'body': 'crate',
                'bodyScale': 0.9,
                'model': model,
                'shadowSize': 0.3,
                'colorTexture': tex,
                'reflection': 'soft',
                'reflectionScale': [0.23],
                'materials': materials})
    
        elif self.bombType in ['teleport', 'heavy', 'zawarudo']:
            fuseTime = 3000;
            self.node = bs.newNode('bomb', delegate=self, attrs={
                'position': position,
                'velocity': velocity,
                'body': 'sphere',
                'model': model, 
                'density': 1.6 if self.bombType == 'heavy' else 1.0 if self.bombType == 'teleport' else 1.2,
                'shadowSize': 0.3,
                'colorTexture': tex,
                'reflection': 'sharper',
                'reflectionScale': [1.8] if self.bombType == 'heavy' else (0, 1.8, 0.68) if bombType == 'teleport' else (0, 1, 1),
                'materials': materials})
    
        elif self.bombType in ['dirty', 'poison']:
            fuseTime = 4500;
            self.node = bs.newNode('bomb', delegate=self, attrs={
                'position': position,
                'velocity': velocity,
                'body': 'sphere',
                'model': model,
                'shadowSize':0.3,
                'colorTexture': tex,
                'reflection': 'soft',
                'reflectionScale': (1, 1.5, 1) if self.bombType == 'poison' else (1, 0.4, 0.16),
                'materials': materials})
            
        elif self.bombType == 'jumping':
            fuseTime = 4500; 
            self.node = bs.newNode('bomb', delegate=self, attrs={
                'position': position,
                'velocity': velocity,
                'body': 'sphere',
                'bodyScale': 0.772,
                'density': 1.772,
                'model': model,
                'shadowSize': 0.3,
                'colorTexture': tex,
                'owner': owner,
                'reflection': 'sharper',
                'reflectionScale': [1.2],
                'materials': materials})
            bs.gameTimer(4320, bs.WeakCall(self.handleMessage, bs.DieMessage()))
            bs.gameTimer(4319, bs.Call(jumping_bomb_explode, self))
        else: return
        fuse(fuseTime=fuseTime)
        if self.bombType == 'firework': bs.animate(self.node, "modelScale", {0: 0, 200: 0.85, 260: 0.8})
        else: bs.animate(self.node, "modelScale", {0: 0, 200: 1.3, 260: 1})
    else: BOMB_INIT(self, position=position, velocity=velocity, bombType=bombType, blastRadius=blastRadius, sourcePlayer=sourcePlayer, owner=owner)
    settings = getattr(factory, 'settings', {})

    if bombType == 'impact': fuseTime = 20000
    elif bombType in ['ice','sticky','normal']: fuseTime = 3000

    if 'fuseTime' not in dir(): return
    if settings.get("timer_before_the_bomb_explode", True):
        m = bs.newNode('math', attrs={'input1': (0, 0.45, 0), 'operation': 'add'})
        self.node.connectAttr('position', m, 'input2')
        self.timer = bs.newNode('text', owner=self.node, attrs={
            'text': '( )',
            'position': (0, 0, 0),
            'color': (0,3,0),
            'scale': 0,
            'inWorld': True,
            'hAlign': 'center'})
        m.connectAttr('output', self.timer, 'position')        
        bs.animate(self.timer, 'scale', {0: 0.0, 240: 0.009})
        bs.animateArray(self.timer, 'color',3, {0: (0,3,0), fuseTime: (3,0,0)}, False)

def __blast_init__(self, position=(0,1,0), velocity=(0,0,0), blastRadius=2.0, blastType="normal", sourcePlayer=None, hitType='explosion', hitSubType='normal'):
    if blastType in NEW_BOMBS:
        bs.Actor.__init__(self)
        factory = getNewBombsFactory()

        self.blastType = blastType; self.sourcePlayer = sourcePlayer
        self.hitType = hitType; self.hitSubType = hitSubType
        self.radius = blastRadius if self.blastType != 'jumping' else 0.8

        if self.blastType == 'dirty': materials = (factory.dirtyBlastMaterial, bs.getSharedObject('attackMaterial'))
        else: materials = (factory.blastMaterial, )
        self.node = bs.newNode('region', delegate=self, attrs={
            'position': (position[0], position[1]-0.1, position[2]),
            'scale': (self.radius, self.radius, self.radius),
            'type': 'sphere',
            'materials': materials})
        if self.blastType == 'dirty': 
            bs.gameTimer(6950, bs.Call(dirt_bomb_death, self.node.getDelegate()))
            bs.gameTimer(7000, self.node.delete)
        else: bs.gameTimer(10, self.node.delete)
        
        if self.blastType == "firework": color = (0.6, 1, 1)
        elif self.blastType == "heavy": color = (0.3, 0.3, 0.3)
        else: color = (1, 0.8, 0)

        explosion = bs.newNode("explosion", attrs={
            'position': position,
            'velocity':(velocity[0], max(-1.0,velocity[1]), velocity[2]),
            'radius':self.radius,
            'big': False,
            'color': color})
        bs.gameTimer(1000, explosion.delete)

        bs.emitBGDynamics(position=position, velocity=velocity, count=int(1.0+random.random()*4), emitType='tendrils',tendrilType='thinSmoke')
        if self.blastType != 'jumping':
            bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*4), emitType='tendrils', tendrilType='smoke')
            bs.emitBGDynamics(position=position, emitType='distortion', spread=2.0)

        if self.blastType == 'poison':
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=velocity, count=30, spread=2.0, scale=0.4, chunkType='rock', emitType='stickers')
        elif self.blastType == 'firework':
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=(1.1 + random.random(), 1.8 + random.random(), 1.1 + random.random()), count=360+random.randrange(0,40), spread=0.8, scale=0.7, chunkType = 'spark')
        elif self.blastType == 'heavy':
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=velocity, count=15, scale=0.6, chunkType='metal', emitType='stickers')
                bs.emitBGDynamics(position=position, velocity=velocity, count=20, scale=0.7, chunkType='spark', emitType='stickers')
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(6.0+random.random()*12), scale=0.8, spread=1.5,chunkType='spark')
        elif self.blastType == 'dirt':
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*8), spread=0.7,chunkType='slime')
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*8), scale=0.5, spread=0.7,chunkType='slime')
        elif self.blastType == 'jumping':
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=(1+random.random(), 1+random.random(), 1+random.random()), count=10+random.randrange(10,20), spread=1.0, scale=0.4, chunkType = 'spark')
        else:
            def _doEmit():
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*8), chunkType='rock')
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(4.0+random.random()*8), scale=0.5,chunkType='rock')
                bs.emitBGDynamics(position=position, velocity=velocity, count=30, scale=0.7, chunkType='spark', emitType='stickers')
                bs.emitBGDynamics(position=position, velocity=velocity, count=int(18.0+random.random()*20), scale=0.8, spread=1.5, chunkType='spark')
                if random.random() < 0.1:
                    def _emitExtraSparks():
                        bs.emitBGDynamics(position=position, velocity=velocity, count=int(10.0+random.random()*20), scale=0.8, spread=1.5, chunkType='spark')
                    bs.gameTimer(20,_emitExtraSparks)            
        bs.gameTimer(50, _doEmit)

        if self.blastType == 'poison': color = (0, 1, 0); intensity = 0.42
        else: color = (1, 0.3, 0.1); intensity = 1.0


        light = bs.newNode('light', attrs={
            'position': position,
            'volumeIntensityScale': 10.0,
            'color': color})
        if self.blastType == 'jumping':
            bs.animate(light, "intensity", {0: 0, 10: 0.5, 20: 0.55, 700: 1, 900: 0})
            bs.animate(light, "radius", {0: 0, 10: 0.5, 20: 0.55, 700: 0.6, 900: 0})
            bs.gameTimer(900, light.delete)
        elif self.blastType == 'firework':
            bs.animate(light, "intensity", {0: 0, 10: 0.5, 20: 1.0, 1200: 0.5, 4000: 0})
            bs.animate(light, "radius", {0: 0, 10: 0.5, 20: 1.0, 1200: 0.5, 4000: 0})
            bs.gameTimer(4000, light.delete)
        else:
            bs.animate(light, "intensity", {0: 0, 10: intensity*0.5, 20: intensity, 2000: intensity*0.5, 2750: 0})
            bs.animate(light, "radius", {0: 0, 10: 0.5, 20: 1.0, 2000: 0.5, 2750: 0})
            bs.gameTimer(2750, light.delete)

        if self.blastType == 'dirty': color = (0.5, 0.1, 0.02)
        else: color = (light.color[0]-0.05, light.color[1]-0.05, light.color[2]-0.07)
        scorch = bs.newNode('scorch', attrs={
            'position': position,
            'size': self.radius*0.5 if self.blastType != "dirty" else self.radius*0.25 if self.blastType == 'jumping' else self.radius*1.2,
            'big': True if self.blastType == 'dirt' else False,
            'color': color})
        if self.blastType == 'dirty':
            bs.animate(scorch, "presence", {0: 0, 60: 0.55, 2000: 1, 6700: 1, 7250: 0})
            bs.gameTimer(7250, scorch.delete)
        elif self.blastType == 'firework':
            bs.animate(scorch, "presence", {0:0, 3000: 1, 10000: 1, 26000: 0})
            bs.gameTimer(26000, scorch.delete)
        else: 
            bs.animate(scorch, "presence",{0: 0, 60: 0.55, 2000: 1, 5000: 0})
            bs.gameTimer(5000, scorch.delete)

        if self.blastType == 'firework': bs.playSound(factory.hissSound, position=position)
        elif self.blastType == 'heavy': bs.playSound(factory.getRandomExplodeSound(), position=position)
        else:  
            bs.playSound(factory.getRandomExplodeSound(), position=position)
            bs.playSound(factory.debrisFallSound, position=position)

        if self.blastType == 'heavy': intensity = 6.1
        elif self.blastType == 'firework': intensity = 0.5
        elif self.blastType == 'jumping': intensity = 0.32
        elif self.blastType == 'dirty': intensity = 0.2
        else: intensity=1.0
        bs.shakeCamera(intensity)
    else: BLAST_INIT(self, position=position, velocity=velocity, blastRadius=blastRadius, blastType=blastType, sourcePlayer=sourcePlayer, hitType=hitType, hitSubType=hitSubType)

def _updateAI(self):
    if getattr(self, '_slow', False):
        if self.static: return
        t = self.node.position
        ourPos = bs.Vector(t[0], 0, t[2])
        if self.node.holdNode.exists():
            self.node.pickUpPressed = True
            self.node.pickUpPressed = False   
        targetPtRaw, targetVel = self._getTargetPlayerPt()
        if targetPtRaw is None:
            if self.targetPointDefault is not None:
                targetPtRaw = self.targetPointDefault
                targetVel = bs.Vector(0, 0, 0)
            else:
                self.node.moveLeftRight = 0
                self.node.moveUpDown = 0
                return
        targetPtRaw.data[1] = 0
        targetVel.data[1] = 0
        distRaw = (targetPtRaw-ourPos).length()
        targetPt = targetPtRaw + targetVel*distRaw*0.3*self._leadAmount
        diff = (targetPt-ourPos)
        toTarget = diff.normal()
        if self.run:
            self._running = False
            self.node.run = 0.0
        self.node.moveLeftRight = toTarget.x() * 0.25
        self.node.moveUpDown = toTarget.z() * -0.25
    else: UPDATE_AI(self)

bsBomb.Bomb.__init__ = bs.Bomb.__init__ = __bombs_init__
bsBomb.Blast.__init__ = bs.Blast.__init__ = __blast_init__
bsSpaz.SpazBot._updateAI = _updateAI