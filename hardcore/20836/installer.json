# -*- coding: utf-8 -*-
import bs, httplib, urllib2
import os, shutil; import json
from inspect import isclass as is_class
from bsUI import ConfirmWindow as ConfirmWindowUI
import time, threading

debug = 2

class ConfirmWindow(ConfirmWindowUI):
    def __init__(self, text="Are you sure?", description="Bruh", 
        action=None, cancelAction=None, width=360, 
        height=100, cancelIsSelected=False, color=(1, 1, 1), 
        textScale=1.0, okText=None, cancelText=None, originWidget=None):
        cancelButton=True
        self._cancelAction = cancelAction
        spacing = int(height/7)
        ConfirmWindowUI.__init__(self, text=text, action=action,
            width=width, height=height, cancelIsSelected=cancelIsSelected,
            cancelButton=cancelButton, color=color, textScale=textScale, 
            okText=okText, cancelText=cancelText, originWidget=originWidget)
        for t in self._rootWidget.getChildren():
            if t.getWidgetType() == "text" and t.exists(): t.delete()
        spacing = spacing * 0.5
        t = bs.textWidget(parent=self._rootWidget,
            position=(width*0.5, height-spacing),
            size=(0, 0), hAlign="center", vAlign="center",
            text=text, scale=textScale, color=color,
            maxWidth=width*0.9, maxHeight=height-spacing)
        height = (height*0.5) + spacing*2
        t = bs.textWidget(parent=self._rootWidget,
            position=(width*0.5, height),
            size=(0, 0), hAlign="center", vAlign="center",
            text=description, scale=textScale, color=color,
            maxWidth=width*0.9, maxHeight=height)
    def _cancel(self):
        if not self._rootWidget.exists(): return
        ConfirmWindowUI._cancel(self)
        if self._cancelAction is not None: self._cancelAction()

class ConfirmWindow2(ConfirmWindowUI):
    def __init__(self, text="Are you sure?", 
        action=None, width=360, height=100, cancelIsSelected=False,
        color=(1, 1, 1), textScale=1.0, okText=None, cancelText=None, 
        originWidget=None, cancelButton=True):
        ConfirmWindowUI.__init__(self, text=text, action=action,
            width=width, height=height, cancelIsSelected=cancelIsSelected,
            cancelButton=cancelButton, color=color, textScale=textScale, 
            okText=okText, cancelText=cancelText, originWidget=originWidget)
    def _ok(self):
        if not self._rootWidget.exists(): return
        bs.containerWidget(edit=self._rootWidget, transition=('outLeft' if self._transitionOut is None else self._transitionOut))
        if self._action is not None: self._action.__call__()

class ReturnTimer(threading.Thread):
    def __init__(self, lenght, *args):
        threading.Thread.__init__(self)
        if lenght < 0: raise ValueError()

        self._call = args[0] if len(args) > 0 else None
        self._args = args[1:] if len(args) > 1 else None
        self._lenght = float(lenght/1000)
    def run(self):
        try:
            time.sleep(self._lenght)
            if self._args is not None: return self._call(*self._args)
            else: return self._call()
        except Exception:
            bs.callInGameThread(bs.Call(self._call, None))    

def finish_download(url, path, download_size, size_callback=False, *args):
    global DOWNLOADS
    filename = path.split(os.path.sep)[-1]
    DOWNLOADS.append(filename)
    if debug > 0: print("Successfully downloaded: " + filename)
    call = args[0] if len(args) > 0 else None
    a = args[1:] if len(args) > 1 else None
    if call is not None: 
        if a is not None: 
            if size_callback: a += (download_size, )
            call(*a)
        else: call()

class Downloader(threading.Thread):
    def __init__(self, download_url, download_path, rewrite_file=True, send_download_size=False, *args):
        threading.Thread.__init__(self)
        self.errors_count = self._b = 0
        
        self._url = download_url
        self._path = download_path
        self._size_callback = send_download_size
        self._rewrite = rewrite_file
        self._args = args
    def download(self):
        try:
            if not self._rewrite and os.path.exists(self._path): return
            if debug > 0: print("try to download from url: " + self._url)
            self.errors_count = 0
    
            u = self._u = self.open_url(url=self._url)
            f = self._f = self.open_file(path=self._path)
    
            if u is None or f is None: print("download error; " + self._url); time.sleep(1); self.run(); return
            bs.callInGameThread(self.chunk)
        except Exception as E: print(E)
    def end(self):
        self._f.close()
        self._u.close()
        finish_download(self._url, self._path, self._b, self._size_callback, *self._args)
    def chunk(self):
        u = self._u; f = self._f
        try: c = u.read(524288)
        except Exception as E:
            self.errors_count += 1
            if self.errors_count > 49: return
            if debug > 1:
                for i in ["chunk lost: ", E, "try again..."]: print(i)
            bs.realTimer(3000, self.chunk); return
        if not c: self.end(); return
        d = len(c)
        self._b += d
        if self._size_callback: update_bar(d)
        f.write(c); f.flush()
        bs.realTimer(1000, self.chunk)
    def open_file(self, path):
        try: f = open(path, 'w+')
        except Exception as E: 
            self.errors_count += 1; print("file open error;"); print(E)
            if self.errors_count > 4: return None
            else: return ReturnTimer(1000, self.open_file, path).start()
        else: self.errors_count = 0; return f
    def open_url(self, url): 
        try: u = urllib2.urlopen(url)
        except Exception as E: 
            self.errors_count += 1; print("url open error; "+url); print(E)
            if self.errors_count > 29: return None
            else: return ReturnTimer(1000, self.open_url, url).start()
        else: self.errors_count = 0; return u
    def run(self):
        self.download()

class DownloadBar(object):
    def __init__(self, size, color=(0.1, 0, 1), backgroundColor=(0.2, 0.2, 0.2)):
        global DOWNLOAD_BAR
        import bsInternal
        bounds = bs.getUIBounds()
        if bsInternal._getSetting("TV Border"): m = 1.2
        else: m = 1.0
        self._width = (bounds[1]-bounds[0]) * 2 * m
        self._height = (bounds[3]-bounds[2]-30) * 0.075 * m

        self._size = 0
        self._bytes = size
        self.tex = bs.getTexture('bar')
        self.visible = False
        
        self.background = bs.newNode('image', delegate=self, attrs={
            'texture': self.tex,
            'opacity': 0,
            'color': backgroundColor,
            'scale': (self._width, self._height),
            'attach': 'topLeft'})
        self.node = bs.newNode('image', delegate=self, attrs={
            'texture': self.tex,
            'opacity': 0,
            'position': (-int(self._width*0.5), 0),
            'color': color,
            'scale': (0, self._height),
            'attach': 'topCenter'})
        c = self._combine = bs.newNode('combine', owner=self.node, attrs={'size':2})
        c.input0, c.input1 = self._scale = self.node.scale
        c.connectAttr('output', self.node, 'scale')
        DOWNLOAD_BAR = self
    def set_visible(self, visible=True):
        if self.visible != visible:
            if visible:
                bs.animate(self.background, 'opacity', {0: 0.0, 500: 0.27})
                bs.animate(self.node, 'opacity', {0: 0.0, 1000: 0.35})
            else:
                c, d = self.background.opacity, self.node.opacity
                bs.animate(self.background, 'opacity', {0: c, 500: 0.0})
                bs.animate(self.node, 'opacity', {0: d, 1000: 0})
            self.visible = visible
    def update(self, size=0):
        self._size += size
        sc = self._width * 2 * (float(self._size)/float(max(1, self._bytes)))
        dc = self._combine.input0
        bs.animate(self._combine, 'input0', {0: dc, 750: dc+sc})
    def delete(self, immediate=False):
        for node in [self.node, self.background]:
            def delete_immediately(node):
                if node is not None and node.exists(): node.delete()
            if immediate: delete_immediately(node=node)
            else: t = node.opacity; bs.animate(node, 'opacity', {0: t, 1000: 0.0}); bs.gameTimer(1000, bs.Call(delete_immediately, node))
            
def spawn_bar(download_size=0):
    if DOWNLOAD_BAR is not None and DOWNLOAD_BAR.exists(): return
    import bsInternal
    with bs.Context(bsInternal._getForegroundHostSession()):
        bar = DownloadBar(size=download_size)
    return bar
def update_bar(b):
    if DOWNLOAD_BAR is not None and DOWNLOAD_BAR.node.exists():
        import bsInternal
        with bs.Context(bsInternal._getForegroundHostSession()): DOWNLOAD_BAR.update(size=b)
def set_bar_visibility(v):
    if DOWNLOAD_BAR is not None and DOWNLOAD_BAR.node.exists():
        import bsInternal
        with bs.Context(bsInternal._getForegroundHostSession()): DOWNLOAD_BAR.set_visible(visible=v)
def delete_bar():
    if DOWNLOAD_BAR is not None and DOWNLOAD_BAR.node.exists():
        import bsInternal
        with bs.Context(bsInternal._getForegroundHostSession()): DOWNLOAD_BAR.delete(immediate=False)
def test_bar():
    spawn_bar(100)
    set_bar_visibility(True)
    update_bar(50)

colorYellow = (1, 0.85, 0)
colorRed = (1, 0, 0)
colorGreen = (0, 1, 0)

env = bs.getEnvironment()
platform = env['platform']
USER_SCRIPTS_PATH = env['userScriptsDirectory']
SYSTEM_SCRIPTS_PATH = env['systemScriptsDirectory']
del env 

SYSTEM_DIR = os.path.sep.join(SYSTEM_SCRIPTS_PATH.split(os.path.sep)[0:-2]) if platform != 'android' else '/data/data/net.froemling.bombsquad'
GITHUB_BRANCH = 'https://raw.githubusercontent.com/DrovGamedev/BombSquad-Hardcore-Modpack/master' if hasattr(httplib, 'HTTPS') and hasattr(urllib2, 'ssl') else 'http://raw.githack.com/DrovGamedev/BombSquad-Hardcore-Modpack/master'
ERRORS = []
DOWNLOADS = []
DOWNLOAD_BAR = None

def add_scripts():
    import sys
    for path in [SYSTEM_SCRIPTS_PATH, USER_SCRIPTS_PATH]:
        path += os.path.sep + 'hardcore'
        if not os.path.exists(path): return
        sys.path.append(path)
add_scripts()

def has_internet_connection():
    import socket
    s = socket.socket(2, 2)
    s.settimeout(2.0)
    try: s.connect(("8.8.8.8", 80))
    except Exception as E: result = False
    else: result = True
    s.close()
    return result

try: import hardcore
except Exception as E: INSTALLED_VERSION = 0
else: INSTALLED_VERSION = hardcore.get_version(True) if hasattr(hardcore, 'get_version') else 0
if INSTALLED_VERSION is None: INSTALLED_VERSION = 0
try: from hardcore.advanced import get_settings
except: get_settings = lambda : {}
SETTINGS = get_settings()
if debug > 0: print("installed version: " + str(INSTALLED_VERSION))

if debug > 0:
    def error_log(error=None):
        global ERRORS 
        ERRORS.append(error)
        if debug > 1: print(error)
else: error_log = lambda error=None : True

translates = {
    "Russian": {
        "installCompleted": "Установка успешно завершена!",
        "appDataReset": "Сброс данных",
        "appDataResetDesc": "Для более лучшей совместимости, требуется очистить данные игры.\nОчистить данные?",
        "storage": "Хранение",
        "storageDesc": "Кликни на \"Приложение\", если хочешь, \nчтобы данные модпака хранились в приложении.\nИначе, они будут находиться в папке модов",
        "app": "Приложение",
        "modsFolder": "Папка модов",
        "downloadStartsNow": "Загрузка сейчас начнётся.\nПожалуйста, не выходи из игры.",
        "successfullyDownloaded": "Успешно загружено: {}",
        "installThisVersion?": "Установить версию {}?",
        "updateDesc": "Найдено обновление {}.\nУстановить?",
        "update": "Обновление",
        "changelog": "Список изменений",
        "versionFrom": "Версия от {}",
        "additionalFiles": "Дополнительно",
        "additionalFilesDesc": "Скачать новые текстуры и модели?"},
    "English": {
        "installCompleted": "Modpack successfully installed!",
        "appDataReset": "App Data Reset",
        "appDataResetDesc": "For better compatibility, installer need to clear the game data.\nClear data?",
        "storage": "Storage",
        "storageDesc": "Click on \"App\", if you want to save modpack data in app.\Otherwise, they will be stored in the mods folder",
        "app": "App",
        "modsFolder": "Mods Folder",
        "downloadStartsNow": "Download starts now.\nPlease, don\'t quit from game.",
        "successfullyDownloaded": "Successfully downloaded: {}",
        "installThisVersion?": "Install version {}?",
        "updateDesc": "Found update {}.\nInstall it?",
        "update": "Update",
        "changelog": "Changelog",
        "versionFrom": "Version from {}",
        "additionalFiles": "Advanced",
        "additionalFilesDesc": "Download new textures and models?"}
}
translates = translates.get(bs.getLanguage(), translates["English"])

def download(url, path, rewrite=True, send_bytes=False, bar=True, *args):
    set_bar_visibility(bar)
    a = tuple([url])
    a += (path, )
    a += (rewrite, )
    a += (send_bytes, )
    a += args
    with bs.Context("UI"): Downloader(*a).start()

def restart_msg():
    if debug > 1: print("send restart message...")
    bs.screenMessage(bs.Lstr(resource='settingsWindowAdvanced.mustRestartText').evaluate(), color = colorYellow)

def update(version=None, ignore_old=True, download_path=None, auto_update=False):
    global DOWNLOADS
    def on_download_end():
        import sys
        delete_bar()
        try: import script_replacer
        except: restart_msg()
        else: script_replacer._getModulesWithCall("bruh"); print("system scripts replaced")
        bs.realTimer(3000, bs.Call(sys.exit, 1))
    def check_end(paths, urls, c, files_count, download_size):
        bs.screenMessage(translates["successfullyDownloaded"].format(paths.keys()[c].split(":")[-1]), color=colorYellow)
        if len(DOWNLOADS) == files_count: on_download_end()
        else: 
            c += 1
            bs.realTimer(500, bs.Call(download, urls.values()[c], paths.values()[c], True, True, True, check_end, paths, urls, c, files_count))
    def show_changelog(path, download_path, files_count, paths, urls):
        global DOWNLOADS
        DOWNLOADS = []
        try: data = json.load(open(path, 'r'))
        except: data = {}

        u = urls.values()[0]
        p = paths.values()[0]

        data.update({"path": download_path})
        json.dump(data, open(path, 'w+'), indent=4, sort_keys=True)

        changelog = str(data.get("changelog", "").encode('utf-8'))
        changelog = str(bs.Lstr(value=translates["versionFrom"]).evaluate().encode('utf-8')).format(data.get("build", "??.??.??")) + '\n' + changelog
        
        call = bs.Call(download, u, p, True, True, True, check_end, paths, urls, 0, files_count)
        ConfirmWindow(text=bs.Lstr(value=translates["changelog"]), 
            description=bs.Lstr(value=changelog), 
            height=175, textScale=0.9, action=call, 
            okText=bs.Lstr(resource='continueText'))
    def continue_download2(download_path, data, v, download_additional_files):
        global DOWNLOADS
        DOWNLOADS = []
   
        d_size = data[v].get("bytes", 0)
        if 'additional_files' in data[v]:
            if download_additional_files: 
                d_size = data[v].get("additional_bytes", 0)
                additional_files = data[v]['additional_files']
                for u in additional_files: data[v].update({u: additional_files[u]})
        spawn_bar(download_size=int(d_size))
        for m in ['bytes','additional_bytes','additional_files']:
            if m in data[v]: data[v].pop(m)

        url = (GITHUB_BRANCH+'/')
        if download_path is None: download_path = USER_SCRIPTS_PATH
        paths = {}
        urls = {}

        changeLogFile = 'hardcoreModpack.data'

        def d(data, u, p, urls, paths):
            if changeLogFile in data[v].values():
                data[v].pop(data[v].keys()[data[v].values().index(changeLogFile)])
                download(u, p, True, False, False, show_changelog, p, download_path, len(urls), paths, urls)
            else:
                download(u, p, True, True, True, download, u, p, True, True, check_end, paths, urls, 0, len(urls))

        files = {str(i.encode('utf-8')): str(data[v][i].encode('utf-8')) for i in data[v] if isinstance(i, unicode) and isinstance(data[v][i], unicode)}

        changeLogFileUrl = changeLogFilePath = None
        for u in files:
            file = files[u]

            extra_path = file.replace(":", os.path.sep)
            extra_url = (url + u)
            filename = extra_path.split(os.path.sep)[-1]
            if filename == 'installer.py': p = USER_SCRIPTS_PATH + os.path.sep + extra_path
            else: p = download_path + os.path.sep + extra_path

            if filename == changeLogFile: changeLogFileUrl = extra_url; changeLogFilePath = p
            else:
                urls.update({filename: extra_url})
                paths.update({filename: p})

            dirs = p.replace(os.path.sep + filename, "")
            if not os.path.exists(dirs):
                try: os.makedirs(dirs)
                except: pass
        if changeLogFile in files.values(): d(data=data, u=changeLogFileUrl, p=changeLogFilePath, urls=urls, paths=paths)
        else: d(data=data, u=urls[urls.keys()[0]], p=paths[paths.keys()[0]], urls=urls, paths=paths)
    def continue_download(download_path, data, v):

        ok_call = bs.Call(continue_download2, download_path, data, v, True)
        cancel_call = bs.Call(continue_download2, download_path, data, v, False)

        if 'additional_files' in data[v]:
            ConfirmWindow(text=bs.Lstr(value=translates["additionalFiles"]), 
                description=bs.Lstr(value=translates["additionalFilesDesc"]), 
                height=175, textScale=0.9, 
                action=ok_call, cancelAction=cancel_call)
        else: cancel_call()       
    def confirm_download(path, download_path):
        if not os.path.exists(path): return

        try: data = json.load(open(path, 'r'))
        except: data = {}

        if version is None and 'last_version' in data: v = str(data['last_version'])
        elif str(version) in data: v = str(version)
        else: return

        if v not in data: return

        if ignore_old and INSTALLED_VERSION >= int(v) and debug < 4: 
            if debug > 0: print("installed version equals or bigger than installing version; return")
            return

        call = bs.Call(continue_download, download_path, data, v)
        if not auto_update: 
            ConfirmWindow2(text=bs.Lstr(value=translates["installThisVersion?"].format(v)), 
                action=call)
        else: 
            ConfirmWindow(text=bs.Lstr(value=translates["update"]), 
                description=bs.Lstr(value=translates["updateDesc"].format(v)), 
                height=175, textScale=0.9, 
                action=call)

    if not has_internet_connection(): 
        if debug > 1: print("no internet connection")
        return
    filename = 'versions.json' 
    url = GITHUB_BRANCH + '/' + filename
    path = USER_SCRIPTS_PATH + os.path.sep + filename
    download(url, path, True, False, False, confirm_download, path, download_path)

def delete_path(path=None):
    path += os.path.sep + 'hardcore'
    if not os.path.exists(path): return
    try: shutil.rmtree(path)
    except: pass

def delete():
    for path in [SYSTEM_SCRIPTS_PATH, USER_SCRIPTS_PATH]: delete_path(path=path)
    delete_files = ['installer','script_replacer','ui','mainmenu']
    temp_files = ['bsUI','bsMainMenu','menuMusic']
    try: import hardcore
    except: path = USER_SCRIPTS_PATH
    else: path = hardcore.get_path()
    for file in os.listdir(path):
        f = '.'.join(file.split('.')[0:-1])
        if f in delete_files:
            try: os.remove(path + os.path.sep + file)
            except: pass
    for root, dirs, files in os.walk(SYSTEM_SCRIPTS_PATH.replace("scripts","")):
        for file in files:
            if file.endswith('.temp'):
                p = root + os.path.sep
                try: shutil.move(p + file, p + file.replace('.temp', ''))
                except: pass
    restart_msg()

def update_modpack():
    def d(path):
        bs.realTimer(3000, bs.Call(update, None, True, path))
    def a(path=None):
        try: import hardcore
        except: pass
        else: 
            p = hardcore.get_path()
            if p != path: delete_path(p)
        bs.screenMessage(translates["downloadStartsNow"], color=colorYellow)
        import bsInternal
        bsInternal._addCleanFrameCallback(bs.Call(d, path))
    def reset():
        if os.path.exists(SYSTEM_DIR): 
            try: shutil.rmtree(SYSTEM_DIR)
            except: pass
        next_window()
    def next_window():
        ConfirmWindow(text=bs.Lstr(value=translates["storage"]),
            description=bs.Lstr(value=translates["storageDesc"]),
            height=175, action=c, cancelAction=b, 
            okText=bs.Lstr(value=translates["app"]), 
            cancelText=bs.Lstr(value=translates["modsFolder"]),
            textScale=0.9)
    def b():
        a(USER_SCRIPTS_PATH)
    def c():
        a(SYSTEM_SCRIPTS_PATH)
    ConfirmWindow(text=bs.Lstr(value=translates["appDataReset"]),
        description=bs.Lstr(value=translates["appDataResetDesc"]),
        height=150, action=reset, cancelAction=next_window)

if INSTALLED_VERSION == 0 or debug > 3: bs.realTimer(3000, bs.Call(update_modpack))
elif SETTINGS.get("auto-update", False): 
    try: import hardcore
    except: path = None
    else: path = hardcore.get_path()
    bs.realTimer(3000, bs.Call(update, None, True, path, True))