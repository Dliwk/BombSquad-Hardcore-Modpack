# -*- coding: utf-8 -*-
import bs, bsInternal
from bsUI import _updateTabButtonColors, gSmallUI, gToolbars, gMedUI
import os, shutil; import bsUI

# written by drov.drov

env = bs.getEnvironment()
PLATFORM = env['platform']
USER_SCRIPTS_PATH = env['userScriptsDirectory']
del env

SET_TAB = bsUI.WatchWindow._setTab
basepath = (os.path.sep).join(USER_SCRIPTS_PATH.split(os.path.sep)[0:-1])
debug = 0

translates = {
    "Russian": {
        "savedReplays": "Сохраненные реплеи",
        "uploadReplays": "Загрузить реплеи",
        "saveReplays": "Сохранить реплеи"
    },
    "English": {
        "savedReplays": "Saved Replays",
        "uploadReplays": "Replays Upload",
        "saveReplays": "Save Replays"
    }
}
translates = translates.get(bs.getLanguage(), translates["English"])

if PLATFORM == "android":
    REPLAYS_PATH = bsInternal._getReplaysDir()
    REPLAYS_SAVE_PATH = USER_SCRIPTS_PATH + os.path.sep + translates["savedReplays"]
    if not os.path.exists(REPLAYS_SAVE_PATH): os.makedirs(REPLAYS_SAVE_PATH)
    LOG = USER_SCRIPTS_PATH + os.path.sep + 'replaysInfo.txt'
    def get_log(mode='w+'):
        try: return open(LOG, mode)
        except: return None
    def get_mode():
        if not os.path.exists(LOG): mode='w+'
        else: mode = 'a'
    def on_start():
        mode = get_mode()
        f = get_log(mode=mode)
        if f is None: return
        f.write('Replays Mod v.0.1 log file\n\n' if mode == 'w+' else '------------------------\n\n'); f.flush(); f.close()
    on_start()
    def write_log(msgs=['']):
        f = get_log(mode=get_mode())
        if f is None: return
        for msg in msgs: 
            msg = str(bs.Lstr(value=msg).evaluate().encode('utf-8')); f.write(msg); f.flush()
        f.close()

    def exception(error=None):
        if debug < 1: return 
        f = get_log(mode=get_mode())
        if f is None: return
        f.write(str(error)+'\n'); f.flush(); f.close()
 
    def refreshReplays():
        if bsUI.uiGlobals.get('watch_window', None) is not None:
            bsUI.uiGlobals['watch_window']._refreshMyReplays()
            bsUI.uiGlobals['watch_window'] = None
    
    def get_replays(paths=[], replace_files=True):
        for path in paths:
            filename = path.split(os.path.sep)[-1]
            temp = REPLAYS_SAVE_PATH + os.path.sep + filename
            if replace_files and os.path.exists(temp): 
                try: os.remove(temp)
                except: pass
            try: shutil.copy(path, REPLAYS_SAVE_PATH)
            except: pass
            write_log("Successfully saved: "+filename+'\n')
        refreshReplays()
    
    def upload_replays(paths=[]):
        for path in paths:
            filename = path.split(os.path.sep)[-1]
            try: shutil.move(path, str(REPLAYS_PATH.encode('utf-8'))+os.path.sep+filename)
            except: pass
            write_log("Successfully uploaded: "+filename+'\n')
        refreshReplays()

    def uploadReplays(self):
        bsUI.uiGlobals['watch_window'] = self
        select_replays(basepath, callback=checkForUploadReplays)

    def getReplays(self):
        bsUI.uiGlobals['watch_window'] = self
        select_replays(REPLAYS_PATH, callback=checkForSavedReplays)

    def checkForUploadReplays(result=None):
        if result is not None and len(result) > 0: upload_replays(paths=result)
    
    def checkForSavedReplays(result=None):
        if result is not None and len(result) > 0: get_replays(paths=result)

    def fileCheckBox(parent, name, position, scale=None, maxWidth=None, valueChangeCall=None):
        def _valueChanged(val):
            if valueChangeCall is not None: valueChangeCall(name, val)
    
        return bs.checkBoxWidget(parent=parent, autoSelect=True, position=position, size=(50, 50), text='',
            textColor=(0.8, 0.8, 0.8), value=False, onValueChangeCall=_valueChanged, scale=scale, maxWidth=maxWidth)

    class ReplaySelector(bsUI.FileSelectorWindow):
        def __init__(self, path, callback=None):
            bsUI.FileSelectorWindow.__init__(self, path=path, callback=callback, showBasePath=True, validFileExtensions=['brp'], allowFolders=False)
            xInset = 87 if gSmallUI else 40
            self.result = []
            self._doneButton = b = bs.buttonWidget(
                parent=self._rootWidget, position=(self._width - xInset - self._buttonWidth, self._height - 67),
                autoSelect=True, size=(self._buttonWidth, 50),
                label=bs.Lstr(resource='doneText'),
                onActivateCall=self._done)
        def _done(self):
            if self._callback is not None: self._callback(self.result)
            bs.containerWidget(edit=self._rootWidget, transition='outRight')
        def on_entry_request(self, entry, delete=False):
            if entry is not None:
                if not delete and entry not in self.result: self.result.append(entry)
                elif delete: self.result.remove(entry)
        def fileSelectCallback(self, entry, val=False):
            self.on_entry_request(entry=entry, delete=not val)
        def _select_dir(self, path):
            if path is not None: self._setPath(path, True)
        def _getReplayDisplayName(self, replay):
            if replay.endswith('.brp'): replay = replay[:-4]
            if replay == '__lastReplay': return bs.Lstr(resource='replayNameDefaultText').evaluate()
            return replay
        def _refresh(self, fileNames=None, error=None):
            if not self._rootWidget.exists(): return
            scrollWidgetSelected = (self._scrollWidget is None or self._rootWidget.getSelectedChild() == self._scrollWidget)
            inTopFolder = (self._path == self._basePath)
            hideTopFolder = inTopFolder and self._showBasePath is False
            folderName = '' if hideTopFolder else '/' if self._path == '/' else os.path.basename(self._path)
    
            if len(self._recentPaths) < 2: bs.buttonWidget(edit=self._backButton, color=(0.65, 0.65, 0.65), textColor=(0.5, 0.5, 0.5))
            else: bs.buttonWidget(edit=self._backButton, color=(0.6, 0.53, 0.63), textColor=(0.75, 0.7, 0.8))
    
            bs.textWidget(edit=self._pathText, text=folderName, maxWidth=300)
            bs.imageWidget(edit=self._folderIcon, position=(
                self._folderCenter-min(300, bsInternal._getStringWidth(folderName, suppressWarning=True))*0.5-40,
                self._height-117), opacity=0.0 if hideTopFolder else 1.0)
    
            if self._scrollWidget is not None and self._scrollWidget.exists(): self._scrollWidget.delete()
    
            if self._useFolderButton is not None and self._userFolderButton.exists(): 
                self._useFolderButton.delete() 
                bs.widget(edit=self._cancelButton, rightWidget=self._backButton)
    
            self._scrollWidget = bs.scrollWidget(
                parent=self._rootWidget,
                position=((self._width-self._scrollWidth)*0.5, self._height-self._scrollHeight-119),
                size=(self._scrollWidth,self._scrollHeight))
    
            if scrollWidgetSelected: bs.containerWidget(edit=self._rootWidget, selectedChild=self._scrollWidget)
            if error is not None:
                self._subContainer = bs.containerWidget(
                    parent=self._scrollWidget,
                    size=(self._scrollWidth, self._scrollHeight),
                    background=False)
                bs.textWidget(
                    parent=self._subContainer, color=(1, 1, 0, 1),
                    text=error, maxWidth=self._scrollWidth * 0.9,
                    position=(self._scrollWidth * 0.48, self._scrollHeight * 0.57),
                    size=(0, 0),
                    hAlign='center', vAlign='center')
            else:
                if fileNames is None: return
                fileNames.sort(key=lambda x: x[0].lower())
    
                entryHeight = 35
    
                folderEntryHeight = 100
                showFolderEntry = False
    
                showUseFolderButton = (self._allowFolders and not inTopFolder)
    
                self._subContainerHeight = entryHeight*len(fileNames) + (folderEntryHeight if showFolderEntry else 0)
                v = self._subContainerHeight - (folderEntryHeight if showFolderEntry else 0)
    
                self._subContainer = bs.containerWidget(
                    parent=self._scrollWidget,
                    size=( self._scrollWidth, self._subContainerHeight),
                    background=False)
    
                bs.containerWidget(edit=self._scrollWidget, claimsLeftRight=False, claimsTab=False)
                bs.containerWidget(
                    edit=self._subContainer, claimsLeftRight=False, claimsTab=False,
                    selectionLoops=False, printListExitInstructions=False)
                bs.widget(edit=self._subContainer, upWidget=self._backButton)
    
                if showUseFolderButton:
                    self._useFolderButton = b = bs.buttonWidget(
                        parent=self._rootWidget,
                        position=(self._width - self._buttonWidth - 35 - self._xInset, self._height - 67),
                        size=(self._buttonWidth, 50),
                        label=bs.Lstr(resource=self._r + '.useThisFolderButtonText'),
                        onActivateCall=self._onFolderEntryActivated)
                    bs.widget(edit=b, leftWidget=self._cancelButton, downWidget=self._scrollWidget)
                    bs.widget(edit=self._cancelButton, rightWidget=b)
                    bs.containerWidget(edit=self._rootWidget, startButton=b)
    
                folderIconSize = 35
                for num, entry in enumerate(fileNames):
                    try: entryPath = str(self._path.encode('utf-8'))+os.path.sep+str(entry.encode('utf-8'))
                    except: entryPath = self._path + os.path.sep + str(entry.encode('utf-8'))
                    isValidFilePath = self._isValidFilePath(entry)
                    isDir = os.path.isdir(entryPath)
                    c = bs.containerWidget(
                        parent=self._subContainer, position=(0, v - entryHeight),
                        size=(self._scrollWidth, entryHeight),
                        rootSelectable=True if isDir else False, background=False, clickActivate=True if isDir else False,
                        onActivateCall=bs.Call(self._select_dir, entryPath) if isDir else None)
                    if num == 0: bs.widget(edit=c, upWidget=self._backButton)
                    if isDir:
                        i = bs.imageWidget(
                            parent=c, size=(folderIconSize, folderIconSize),
                            position=(10, 0.5 * entryHeight - folderIconSize * 0.5),
                            drawController=c, texture=self._folderTex,
                            color=self._folderColor)
                    else:
                        i = bs.imageWidget(
                            parent=c, size=(folderIconSize, folderIconSize),
                            position=(10, 0.5 * entryHeight - folderIconSize * 0.5),
                            opacity=1.0 if isValidFilePath else 0.5,
                            drawController=c, texture=self._fileTex,
                            color=self._fileColor)
                        if entry.endswith('.brp'):
                            fileCheckBox(parent=c, name=entryPath, position=(self._width-130, -5), 
                                valueChangeCall=self.fileSelectCallback)
                            entry = str(self._getReplayDisplayName(entry).encode('utf-8'))
                    t = bs.textWidget(
                        parent=c, drawController=c, text=entry, hAlign='left',
                        vAlign='center',
                        position=(10 + folderIconSize * 1.05, entryHeight * 0.5),
                        size=(0, 0),
                        maxWidth=self._scrollWidth * 0.93 - 50, color=(1, 1, 1, 1)
                        if(isValidFilePath or isDir) else(0.5, 0.5, 0.5, 1))
                    v -= entryHeight

    def select_replays(path=None, callback=None):
        if path is not None and os.path.exists(bs.utf8(path)):
            bsUI.uiGlobals['mainMenuWindow'] = ReplaySelector(path=path, callback=callback).getRootWidget()

    def _setTab(self, tab):
        SET_TAB(self, tab=tab)
        for widget in self._tabContainer.getChildren():
            if widget is not None and widget.exists() and widget.getWidgetType() == 'button': widget.delete()
        if tab == 'myReplays':
            cWidth = self._scrollWidth 
            cHeight = self._scrollHeight-20

            bWidth = 140 if gSmallUI else 178 #
            bHeight = 64 if gSmallUI else 83 if gMedUI else 107 #
            bSpaceExtra = 3 if gSmallUI else 1 if gMedUI else 5 #
            bv = cHeight-(48 if gSmallUI else 45 if gMedUI else 40)-bHeight #
            bh = 40 if gSmallUI else 40 #
            sh = 190 if gSmallUI else 225 #
            ts = 1.0 if gSmallUI else 1.2 #
            bColor = (0.6, 0.53, 0.63)
            bTextColor = (0.75, 0.7, 0.8)
            c = self._tabContainer
            
            self._myReplaysWatchReplayButton = b1 = bs.buttonWidget(
                parent=c, size=(bWidth, bHeight),
                position=(bh, bv),
                buttonType='square', color=bColor, textColor=bTextColor,
                onActivateCall=self._onMyReplayPlayPress, textScale=ts,
                label=bs.Lstr(resource=self._r + '.watchReplayButtonText'),
                autoSelect=True)
            bs.widget(edit=b1, upWidget=self._tab_buttons[tab])
            if gSmallUI and gToolbars: bs.widget(edit=b1, leftWidget=bsInternal._getSpecialWidget('backButton'))
            bv -= bHeight+bSpaceExtra
            b2 = bs.buttonWidget(
                parent=c, size=(bWidth, bHeight),
                position=(bh, bv),
                buttonType='square', color=bColor, textColor=bTextColor,
                onActivateCall=self._onMyReplayRenamePress, textScale=ts,
                label=bs.Lstr(resource=self._r + '.renameReplayButtonText'),
                autoSelect=True)
            bv -= bHeight+bSpaceExtra
            b3 = bs.buttonWidget(
                parent=c, size=(bWidth, bHeight),
                position=(bh, bv),
                buttonType='square', color=bColor, textColor=bTextColor,
                onActivateCall=self._onMyReplayDeletePress, textScale=ts,
                label=bs.Lstr(resource=self._r + '.deleteReplayButtonText'),
                autoSelect=True)
            bv -= bHeight+bSpaceExtra
            b4 = bs.buttonWidget(
                parent=c, size=(bWidth, bHeight),
                position=(bh, bv),
                buttonType='square', color=bColor, textColor=bTextColor,
                onActivateCall=bs.Call(getReplays, self), textScale=ts,
                label=bs.Lstr(value=translates["saveReplays"]),
                autoSelect=True)
            bv -= bHeight+bSpaceExtra
            b5 = bs.buttonWidget(
                parent=c, size=(bWidth, bHeight),
                position=(bh, bv),
                buttonType='square', color=bColor, textColor=bTextColor,
                onActivateCall=bs.Call(uploadReplays, self), textScale=ts,
                label=bs.Lstr(value=translates["uploadReplays"]),
                autoSelect=True)
            self._myReplaySelected = None
            self._refreshMyReplays()
    bsUI.WatchWindow._setTab = _setTab
        